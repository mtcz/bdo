<?php
/**
 * KpoApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * v1 Waste Register public Api
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * KpoApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class KpoApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation approveKpo
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ApproveKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function approveKpo($request = null)
    {
        list($response) = $this->approveKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation approveKpoWithHttpInfo
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ApproveKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->approveKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approveKpoAsync
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ApproveKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveKpoAsync($request = null)
    {
        return $this->approveKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveKpoAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ApproveKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->approveKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ApproveKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function approveKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignReceiveConfirmationToKpo
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1AssignReceiveConfirmationToKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function assignReceiveConfirmationToKpo($request = null)
    {
        list($response) = $this->assignReceiveConfirmationToKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation assignReceiveConfirmationToKpoWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1AssignReceiveConfirmationToKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignReceiveConfirmationToKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->assignReceiveConfirmationToKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation assignReceiveConfirmationToKpoAsync
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1AssignReceiveConfirmationToKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignReceiveConfirmationToKpoAsync($request = null)
    {
        return $this->assignReceiveConfirmationToKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignReceiveConfirmationToKpoAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1AssignReceiveConfirmationToKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignReceiveConfirmationToKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->assignReceiveConfirmationToKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignReceiveConfirmationToKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1AssignReceiveConfirmationToKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assignReceiveConfirmationToKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/assign/receiveconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeKpoStatusToTransportConfirmation
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationResponse
     */
    public function changeKpoStatusToTransportConfirmation($request = null)
    {
        list($response) = $this->changeKpoStatusToTransportConfirmationWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation changeKpoStatusToTransportConfirmationWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeKpoStatusToTransportConfirmationWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationResponse';
        $request = $this->changeKpoStatusToTransportConfirmationRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeKpoStatusToTransportConfirmationAsync
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeKpoStatusToTransportConfirmationAsync($request = null)
    {
        return $this->changeKpoStatusToTransportConfirmationAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeKpoStatusToTransportConfirmationAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeKpoStatusToTransportConfirmationAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationResponse';
        $request = $this->changeKpoStatusToTransportConfirmationRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeKpoStatusToTransportConfirmation'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ChangeKpoStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeKpoStatusToTransportConfirmationRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/status/transportconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKpo
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1DeleteKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKpo($request = null)
    {
        list($response) = $this->deleteKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKpoWithHttpInfo
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1DeleteKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKpoAsync
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1DeleteKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKpoAsync($request = null)
    {
        return $this->deleteKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKpoAsyncWithHttpInfo
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1DeleteKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1DeleteKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateKpoConfirmation
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Potwierdzenie wygenerowane\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1GenerateKpoConfirmationRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function generateKpoConfirmation($request = null)
    {
        list($response) = $this->generateKpoConfirmationWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation generateKpoConfirmationWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Potwierdzenie wygenerowane\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1GenerateKpoConfirmationRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateKpoConfirmationWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->generateKpoConfirmationRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateKpoConfirmationAsync
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Potwierdzenie wygenerowane\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1GenerateKpoConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateKpoConfirmationAsync($request = null)
    {
        return $this->generateKpoConfirmationAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateKpoConfirmationAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Potwierdzenie wygenerowane\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1GenerateKpoConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateKpoConfirmationAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->generateKpoConfirmationRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateKpoConfirmation'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1GenerateKpoConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generateKpoConfirmationRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/generateconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApprovedKpo
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ApprovedKpoDto
     */
    public function getApprovedKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getApprovedKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getApprovedKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ApprovedKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApprovedKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ApprovedKpoDto';
        $request = $this->getApprovedKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ApprovedKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApprovedKpoAsync
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovedKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getApprovedKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApprovedKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovedKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ApprovedKpoDto';
        $request = $this->getApprovedKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApprovedKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApprovedKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/approved/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConfirmationGeneratedKpo
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ConfirmationGeneratedKpoDto
     */
    public function getConfirmationGeneratedKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getConfirmationGeneratedKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getConfirmationGeneratedKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ConfirmationGeneratedKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConfirmationGeneratedKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ConfirmationGeneratedKpoDto';
        $request = $this->getConfirmationGeneratedKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ConfirmationGeneratedKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConfirmationGeneratedKpoAsync
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConfirmationGeneratedKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getConfirmationGeneratedKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConfirmationGeneratedKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConfirmationGeneratedKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ConfirmationGeneratedKpoDto';
        $request = $this->getConfirmationGeneratedKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConfirmationGeneratedKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConfirmationGeneratedKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/confirmationgenerated/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKpoPrintingPage
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoPrintingPage
     */
    public function getKpoPrintingPage($kpo_id = null)
    {
        list($response) = $this->getKpoPrintingPageWithHttpInfo($kpo_id);
        return $response;
    }

    /**
     * Operation getKpoPrintingPageWithHttpInfo
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoPrintingPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKpoPrintingPageWithHttpInfo($kpo_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoPrintingPage';
        $request = $this->getKpoPrintingPageRequest($kpo_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoPrintingPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKpoPrintingPageAsync
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKpoPrintingPageAsync($kpo_id = null)
    {
        return $this->getKpoPrintingPageAsyncWithHttpInfo($kpo_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKpoPrintingPageAsyncWithHttpInfo
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKpoPrintingPageAsyncWithHttpInfo($kpo_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoPrintingPage';
        $request = $this->getKpoPrintingPageRequest($kpo_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKpoPrintingPage'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKpoPrintingPageRequest($kpo_id = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/printingpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPlannedKpo
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto
     */
    public function getPlannedKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getPlannedKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getPlannedKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPlannedKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto';
        $request = $this->getPlannedKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPlannedKpoAsync
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlannedKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getPlannedKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPlannedKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlannedKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto';
        $request = $this->getPlannedKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPlannedKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPlannedKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/planned/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReceiveConfirmedKpo
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiveConfirmedKpoDto
     */
    public function getReceiveConfirmedKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getReceiveConfirmedKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getReceiveConfirmedKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiveConfirmedKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiveConfirmedKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiveConfirmedKpoDto';
        $request = $this->getReceiveConfirmedKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiveConfirmedKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiveConfirmedKpoAsync
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiveConfirmedKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getReceiveConfirmedKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiveConfirmedKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiveConfirmedKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiveConfirmedKpoDto';
        $request = $this->getReceiveConfirmedKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiveConfirmedKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReceiveConfirmedKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/receiveconfirmed/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReceiverKposAsSender
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $receiver_identification_number Numer identyfikacyjny podmiotu przejmującego odpady (optional)
     * @param  string $receiver_name Nazwa podmiotu przejmującego odpady (optional)
     * @param  string $receiver_nip Nip podmiotu przejmującego odpady (optional)
     * @param  string $card_number Numer Karty Przekazania Odpadów (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiverKpoAsSenderListItemDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function getReceiverKposAsSender($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $receiver_identification_number = null, $receiver_name = null, $receiver_nip = null, $card_number = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        list($response) = $this->getReceiverKposAsSenderWithHttpInfo($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $receiver_identification_number, $receiver_name, $receiver_nip, $card_number, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used);
        return $response;
    }

    /**
     * Operation getReceiverKposAsSenderWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $receiver_identification_number Numer identyfikacyjny podmiotu przejmującego odpady (optional)
     * @param  string $receiver_name Nazwa podmiotu przejmującego odpady (optional)
     * @param  string $receiver_nip Nip podmiotu przejmującego odpady (optional)
     * @param  string $card_number Numer Karty Przekazania Odpadów (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiverKpoAsSenderListItemDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiverKposAsSenderWithHttpInfo($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $receiver_identification_number = null, $receiver_name = null, $receiver_nip = null, $card_number = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiverKpoAsSenderListItemDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->getReceiverKposAsSenderRequest($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $receiver_identification_number, $receiver_name, $receiver_nip, $card_number, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiverKpoAsSenderListItemDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiverKposAsSenderAsync
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $receiver_identification_number Numer identyfikacyjny podmiotu przejmującego odpady (optional)
     * @param  string $receiver_name Nazwa podmiotu przejmującego odpady (optional)
     * @param  string $receiver_nip Nip podmiotu przejmującego odpady (optional)
     * @param  string $card_number Numer Karty Przekazania Odpadów (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiverKposAsSenderAsync($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $receiver_identification_number = null, $receiver_name = null, $receiver_nip = null, $card_number = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        return $this->getReceiverKposAsSenderAsyncWithHttpInfo($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $receiver_identification_number, $receiver_name, $receiver_nip, $card_number, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiverKposAsSenderAsyncWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $receiver_identification_number Numer identyfikacyjny podmiotu przejmującego odpady (optional)
     * @param  string $receiver_name Nazwa podmiotu przejmującego odpady (optional)
     * @param  string $receiver_nip Nip podmiotu przejmującego odpady (optional)
     * @param  string $card_number Numer Karty Przekazania Odpadów (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiverKposAsSenderAsyncWithHttpInfo($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $receiver_identification_number = null, $receiver_name = null, $receiver_nip = null, $card_number = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1ReceiverKpoAsSenderListItemDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->getReceiverKposAsSenderRequest($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $receiver_identification_number, $receiver_name, $receiver_nip, $card_number, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiverKposAsSender'
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $receiver_identification_number Numer identyfikacyjny podmiotu przejmującego odpady (optional)
     * @param  string $receiver_name Nazwa podmiotu przejmującego odpady (optional)
     * @param  string $receiver_nip Nip podmiotu przejmującego odpady (optional)
     * @param  string $card_number Numer Karty Przekazania Odpadów (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReceiverKposAsSenderRequest($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $receiver_identification_number = null, $receiver_name = null, $receiver_nip = null, $card_number = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/receivercards/sender';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['PageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($pagination_parameters_order_is_ascending !== null) {
            $queryParams['PaginationParameters.Order.IsAscending'] = ObjectSerializer::toQueryValue($pagination_parameters_order_is_ascending);
        }
        // query params
        if ($pagination_parameters_order_order_column !== null) {
            $queryParams['PaginationParameters.Order.OrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_order_order_column);
        }
        // query params
        if ($pagination_parameters_page_index !== null) {
            $queryParams['PaginationParameters.Page.Index'] = ObjectSerializer::toQueryValue($pagination_parameters_page_index);
        }
        // query params
        if ($pagination_parameters_page_size !== null) {
            $queryParams['PaginationParameters.Page.Size'] = ObjectSerializer::toQueryValue($pagination_parameters_page_size);
        }
        // query params
        if ($pagination_parameters_get_order_column !== null) {
            $queryParams['PaginationParameters.GetOrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_column);
        }
        // query params
        if ($pagination_parameters_get_order_direction !== null) {
            $queryParams['PaginationParameters.GetOrderDirection'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_direction);
        }
        // query params
        if ($pagination_parameters_get_ordering !== null) {
            $queryParams['PaginationParameters.GetOrdering'] = ObjectSerializer::toQueryValue($pagination_parameters_get_ordering);
        }
        // query params
        if ($receiver_identification_number !== null) {
            $queryParams['ReceiverIdentificationNumber'] = ObjectSerializer::toQueryValue($receiver_identification_number);
        }
        // query params
        if ($receiver_name !== null) {
            $queryParams['ReceiverName'] = ObjectSerializer::toQueryValue($receiver_name);
        }
        // query params
        if ($receiver_nip !== null) {
            $queryParams['ReceiverNip'] = ObjectSerializer::toQueryValue($receiver_nip);
        }
        // query params
        if ($card_number !== null) {
            $queryParams['CardNumber'] = ObjectSerializer::toQueryValue($card_number);
        }
        // query params
        if ($receive_confirmation_time !== null) {
            $queryParams['ReceiveConfirmationTime'] = ObjectSerializer::toQueryValue($receive_confirmation_time);
        }
        // query params
        if ($card_status_code_names !== null) {
            $queryParams['CardStatusCodeNames'] = ObjectSerializer::toQueryValue($card_status_code_names);
        }
        // query params
        if ($waste_code_name !== null) {
            $queryParams['WasteCodeName'] = ObjectSerializer::toQueryValue($waste_code_name);
        }
        // query params
        if ($is_used !== null) {
            $queryParams['IsUsed'] = ObjectSerializer::toQueryValue($is_used);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRejectedKpo
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1RejectedKpoDto
     */
    public function getRejectedKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getRejectedKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getRejectedKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1RejectedKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRejectedKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1RejectedKpoDto';
        $request = $this->getRejectedKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1RejectedKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRejectedKpoAsync
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRejectedKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getRejectedKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRejectedKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRejectedKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1RejectedKpoDto';
        $request = $this->getRejectedKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRejectedKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRejectedKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/rejected/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSenderKposAsReceiver
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $card_number Numer lub fragment numeru karty KPO (optional)
     * @param  string $sender_nip NIP przekazującego odpad (optional)
     * @param  string $sender_identification_number Numer rejestrowy przekazującego odpady (optional)
     * @param  string $sender_name Nazwa lub Imię i Nazwisko przekazującego odpady (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1SenderKpoAsReceiverDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function getSenderKposAsReceiver($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $card_number = null, $sender_nip = null, $sender_identification_number = null, $sender_name = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        list($response) = $this->getSenderKposAsReceiverWithHttpInfo($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $card_number, $sender_nip, $sender_identification_number, $sender_name, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used);
        return $response;
    }

    /**
     * Operation getSenderKposAsReceiverWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $card_number Numer lub fragment numeru karty KPO (optional)
     * @param  string $sender_nip NIP przekazującego odpad (optional)
     * @param  string $sender_identification_number Numer rejestrowy przekazującego odpady (optional)
     * @param  string $sender_name Nazwa lub Imię i Nazwisko przekazującego odpady (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1SenderKpoAsReceiverDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSenderKposAsReceiverWithHttpInfo($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $card_number = null, $sender_nip = null, $sender_identification_number = null, $sender_name = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1SenderKpoAsReceiverDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->getSenderKposAsReceiverRequest($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $card_number, $sender_nip, $sender_identification_number, $sender_name, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1SenderKpoAsReceiverDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSenderKposAsReceiverAsync
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $card_number Numer lub fragment numeru karty KPO (optional)
     * @param  string $sender_nip NIP przekazującego odpad (optional)
     * @param  string $sender_identification_number Numer rejestrowy przekazującego odpady (optional)
     * @param  string $sender_name Nazwa lub Imię i Nazwisko przekazującego odpady (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderKposAsReceiverAsync($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $card_number = null, $sender_nip = null, $sender_identification_number = null, $sender_name = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        return $this->getSenderKposAsReceiverAsyncWithHttpInfo($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $card_number, $sender_nip, $sender_identification_number, $sender_name, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSenderKposAsReceiverAsyncWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $card_number Numer lub fragment numeru karty KPO (optional)
     * @param  string $sender_nip NIP przekazującego odpad (optional)
     * @param  string $sender_identification_number Numer rejestrowy przekazującego odpady (optional)
     * @param  string $sender_name Nazwa lub Imię i Nazwisko przekazującego odpady (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSenderKposAsReceiverAsyncWithHttpInfo($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $card_number = null, $sender_nip = null, $sender_identification_number = null, $sender_name = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1SenderKpoAsReceiverDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->getSenderKposAsReceiverRequest($page_size, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering, $card_number, $sender_nip, $sender_identification_number, $sender_name, $receive_confirmation_time, $card_status_code_names, $waste_code_name, $is_used);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSenderKposAsReceiver'
     *
     * @param  int $page_size Maksymalna liczba wyników wyszukiwania (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     * @param  string $card_number Numer lub fragment numeru karty KPO (optional)
     * @param  string $sender_nip NIP przekazującego odpad (optional)
     * @param  string $sender_identification_number Numer rejestrowy przekazującego odpady (optional)
     * @param  string $sender_name Nazwa lub Imię i Nazwisko przekazującego odpady (optional)
     * @param  \DateTime $receive_confirmation_time Data przekazania odpadów (optional)
     * @param  string $card_status_code_names Lista statusów Kart Przekazania Odpadów rozdzielona średnikami. Słownik wartości dostępny w kontrolerze CardStatus (optional)
     * @param  string $waste_code_name Kod odpadów (optional)
     * @param  bool $is_used  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSenderKposAsReceiverRequest($page_size = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null, $card_number = null, $sender_nip = null, $sender_identification_number = null, $sender_name = null, $receive_confirmation_time = null, $card_status_code_names = null, $waste_code_name = null, $is_used = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/sendercards/receiver';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_size !== null) {
            $queryParams['PageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($pagination_parameters_order_is_ascending !== null) {
            $queryParams['PaginationParameters.Order.IsAscending'] = ObjectSerializer::toQueryValue($pagination_parameters_order_is_ascending);
        }
        // query params
        if ($pagination_parameters_order_order_column !== null) {
            $queryParams['PaginationParameters.Order.OrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_order_order_column);
        }
        // query params
        if ($pagination_parameters_page_index !== null) {
            $queryParams['PaginationParameters.Page.Index'] = ObjectSerializer::toQueryValue($pagination_parameters_page_index);
        }
        // query params
        if ($pagination_parameters_page_size !== null) {
            $queryParams['PaginationParameters.Page.Size'] = ObjectSerializer::toQueryValue($pagination_parameters_page_size);
        }
        // query params
        if ($pagination_parameters_get_order_column !== null) {
            $queryParams['PaginationParameters.GetOrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_column);
        }
        // query params
        if ($pagination_parameters_get_order_direction !== null) {
            $queryParams['PaginationParameters.GetOrderDirection'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_direction);
        }
        // query params
        if ($pagination_parameters_get_ordering !== null) {
            $queryParams['PaginationParameters.GetOrdering'] = ObjectSerializer::toQueryValue($pagination_parameters_get_ordering);
        }
        // query params
        if ($card_number !== null) {
            $queryParams['CardNumber'] = ObjectSerializer::toQueryValue($card_number);
        }
        // query params
        if ($sender_nip !== null) {
            $queryParams['SenderNip'] = ObjectSerializer::toQueryValue($sender_nip);
        }
        // query params
        if ($sender_identification_number !== null) {
            $queryParams['SenderIdentificationNumber'] = ObjectSerializer::toQueryValue($sender_identification_number);
        }
        // query params
        if ($sender_name !== null) {
            $queryParams['SenderName'] = ObjectSerializer::toQueryValue($sender_name);
        }
        // query params
        if ($receive_confirmation_time !== null) {
            $queryParams['ReceiveConfirmationTime'] = ObjectSerializer::toQueryValue($receive_confirmation_time);
        }
        // query params
        if ($card_status_code_names !== null) {
            $queryParams['CardStatusCodeNames'] = ObjectSerializer::toQueryValue($card_status_code_names);
        }
        // query params
        if ($waste_code_name !== null) {
            $queryParams['WasteCodeName'] = ObjectSerializer::toQueryValue($waste_code_name);
        }
        // query params
        if ($is_used !== null) {
            $queryParams['IsUsed'] = ObjectSerializer::toQueryValue($is_used);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransportConfirmationKpo
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1TransportConfirmationKpoDto
     */
    public function getTransportConfirmationKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getTransportConfirmationKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getTransportConfirmationKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1TransportConfirmationKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransportConfirmationKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1TransportConfirmationKpoDto';
        $request = $this->getTransportConfirmationKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1TransportConfirmationKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransportConfirmationKpoAsync
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransportConfirmationKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getTransportConfirmationKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransportConfirmationKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransportConfirmationKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1TransportConfirmationKpoDto';
        $request = $this->getTransportConfirmationKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransportConfirmationKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransportConfirmationKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/transportconfirmation/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWithdrawnKpo
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1GetWithdrawnKpoDto
     */
    public function getWithdrawnKpo($kpo_id = null, $company_type = null)
    {
        list($response) = $this->getWithdrawnKpoWithHttpInfo($kpo_id, $company_type);
        return $response;
    }

    /**
     * Operation getWithdrawnKpoWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1GetWithdrawnKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithdrawnKpoWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1GetWithdrawnKpoDto';
        $request = $this->getWithdrawnKpoRequest($kpo_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1GetWithdrawnKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWithdrawnKpoAsync
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawnKpoAsync($kpo_id = null, $company_type = null)
    {
        return $this->getWithdrawnKpoAsyncWithHttpInfo($kpo_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWithdrawnKpoAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawnKpoAsyncWithHttpInfo($kpo_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1GetWithdrawnKpoDto';
        $request = $this->getWithdrawnKpoRequest($kpo_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWithdrawnKpo'
     *
     * @param  string $kpo_id Id Karty Przekazania Odpadów (optional)
     * @param  string $company_type Rola w której występuje podmiot w procesie przekazania odpadów (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWithdrawnKpoRequest($kpo_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/withdrawn/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpo_id !== null) {
            $queryParams['KpoId'] = ObjectSerializer::toQueryValue($kpo_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation planKpo
     *
     * Tworzenie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1PlanKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto
     */
    public function planKpo($request = null)
    {
        list($response) = $this->planKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation planKpoWithHttpInfo
     *
     * Tworzenie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1PlanKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function planKpoWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto';
        $request = $this->planKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation planKpoAsync
     *
     * Tworzenie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1PlanKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planKpoAsync($request = null)
    {
        return $this->planKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation planKpoAsyncWithHttpInfo
     *
     * Tworzenie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1PlanKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1PlannedKpoDto';
        $request = $this->planKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'planKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1PlanKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function planKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/create/plannedcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rejectKpo
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1RejectKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function rejectKpo($request = null)
    {
        list($response) = $this->rejectKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation rejectKpoWithHttpInfo
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1RejectKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function rejectKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->rejectKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rejectKpoAsync
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1RejectKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rejectKpoAsync($request = null)
    {
        return $this->rejectKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rejectKpoAsyncWithHttpInfo
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1RejectKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rejectKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->rejectKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rejectKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1RejectKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rejectKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/reject';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviseKpo
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ReviseKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function reviseKpo($request = null)
    {
        list($response) = $this->reviseKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation reviseKpoWithHttpInfo
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ReviseKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviseKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->reviseKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviseKpoAsync
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ReviseKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviseKpoAsync($request = null)
    {
        return $this->reviseKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviseKpoAsyncWithHttpInfo
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ReviseKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviseKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->reviseKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviseKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1ReviseKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviseKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/revise';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKpoAsCarrier
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsCarrierRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKpoAsCarrier($request = null)
    {
        list($response) = $this->searchKpoAsCarrierWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKpoAsCarrierWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsCarrierRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKpoAsCarrierWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpoAsCarrierRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKpoAsCarrierAsync
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpoAsCarrierAsync($request = null)
    {
        return $this->searchKpoAsCarrierAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKpoAsCarrierAsyncWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpoAsCarrierAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpoAsCarrierRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKpoAsCarrier'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKpoAsCarrierRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/carrier/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKpoAsReceiver
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsReceiverRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKpoAsReceiver($request = null)
    {
        list($response) = $this->searchKpoAsReceiverWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKpoAsReceiverWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsReceiverRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKpoAsReceiverWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpoAsReceiverRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKpoAsReceiverAsync
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpoAsReceiverAsync($request = null)
    {
        return $this->searchKpoAsReceiverAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKpoAsReceiverAsyncWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpoAsReceiverAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpoAsReceiverRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKpoAsReceiver'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKpoAsReceiverRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/receiver/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKpoAsSender
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsSenderRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKpoAsSender($request = null)
    {
        list($response) = $this->searchKpoAsSenderWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKpoAsSenderWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsSenderRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKpoAsSenderWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpoAsSenderRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKpoAsSenderAsync
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpoAsSenderAsync($request = null)
    {
        return $this->searchKpoAsSenderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKpoAsSenderAsyncWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpoAsSenderAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWasteTransferCardV1KpoAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpoAsSenderRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKpoAsSender'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardSearchCardsV1SearchKpoAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKpoAsSenderRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/sender/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApprovedGenerateConfirmationKpoAsSender
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateApprovedGenerateConfirmationKpoAsSender($request = null)
    {
        list($response) = $this->updateApprovedGenerateConfirmationKpoAsSenderWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateApprovedGenerateConfirmationKpoAsSenderWithHttpInfo
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApprovedGenerateConfirmationKpoAsSenderWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedGenerateConfirmationKpoAsSenderRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateApprovedGenerateConfirmationKpoAsSenderAsync
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedGenerateConfirmationKpoAsSenderAsync($request = null)
    {
        return $this->updateApprovedGenerateConfirmationKpoAsSenderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApprovedGenerateConfirmationKpoAsSenderAsyncWithHttpInfo
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedGenerateConfirmationKpoAsSenderAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedGenerateConfirmationKpoAsSenderRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApprovedGenerateConfirmationKpoAsSender'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateApprovedGenerateConfirmationKpoAsSenderRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/sender/update/approved/generateconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApprovedKpo
     *
     * Edycja karty ze statusem \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateApprovedKpo($request = null)
    {
        list($response) = $this->updateApprovedKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateApprovedKpoWithHttpInfo
     *
     * Edycja karty ze statusem \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApprovedKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateApprovedKpoAsync
     *
     * Edycja karty ze statusem \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedKpoAsync($request = null)
    {
        return $this->updateApprovedKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApprovedKpoAsyncWithHttpInfo
     *
     * Edycja karty ze statusem \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApprovedKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateApprovedKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/update/approvedcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApprovedKpoAndGenerateConfirmationAsCarrier
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoAndGenerateConfirmationAsCarrierRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateApprovedKpoAndGenerateConfirmationAsCarrier($request = null)
    {
        list($response) = $this->updateApprovedKpoAndGenerateConfirmationAsCarrierWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateApprovedKpoAndGenerateConfirmationAsCarrierWithHttpInfo
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoAndGenerateConfirmationAsCarrierRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApprovedKpoAndGenerateConfirmationAsCarrierWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedKpoAndGenerateConfirmationAsCarrierRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateApprovedKpoAndGenerateConfirmationAsCarrierAsync
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoAndGenerateConfirmationAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedKpoAndGenerateConfirmationAsCarrierAsync($request = null)
    {
        return $this->updateApprovedKpoAndGenerateConfirmationAsCarrierAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApprovedKpoAndGenerateConfirmationAsCarrierAsyncWithHttpInfo
     *
     * Wygenerowanie potwierdzenia (zmiana statusu karty na \"Potwierdzenie wygenerowane\") dla karty ze statusem \"Zatwierdzona\", gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoAndGenerateConfirmationAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedKpoAndGenerateConfirmationAsCarrierAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedKpoAndGenerateConfirmationAsCarrierRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApprovedKpoAndGenerateConfirmationAsCarrier'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdateApprovedKpoAndGenerateConfirmationAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateApprovedKpoAndGenerateConfirmationAsCarrierRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/carrier/update/approved/generateconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePlannedKpo
     *
     * Edycja karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdatePlannedKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updatePlannedKpo($request = null)
    {
        list($response) = $this->updatePlannedKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updatePlannedKpoWithHttpInfo
     *
     * Edycja karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdatePlannedKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePlannedKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updatePlannedKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePlannedKpoAsync
     *
     * Edycja karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdatePlannedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePlannedKpoAsync($request = null)
    {
        return $this->updatePlannedKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePlannedKpoAsyncWithHttpInfo
     *
     * Edycja karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdatePlannedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePlannedKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updatePlannedKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePlannedKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1UpdatePlannedKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePlannedKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/update/plannedcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation withdrawnKpo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1WithdrawnKpoRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function withdrawnKpo($request = null)
    {
        list($response) = $this->withdrawnKpoWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation withdrawnKpoWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1WithdrawnKpoRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function withdrawnKpoWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->withdrawnKpoRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation withdrawnKpoAsync
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1WithdrawnKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawnKpoAsync($request = null)
    {
        return $this->withdrawnKpoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation withdrawnKpoAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1WithdrawnKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawnKpoAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->withdrawnKpoRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'withdrawnKpo'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWasteTransferCardV1WithdrawnKpoRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function withdrawnKpoRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpo/withdrawn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
