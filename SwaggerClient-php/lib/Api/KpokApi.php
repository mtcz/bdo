<?php
/**
 * KpokApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * v1 Waste Register public Api
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * KpokApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class KpokApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation approveKpok
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ApproveKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApproveKpokResponse
     */
    public function approveKpok($request = null)
    {
        list($response) = $this->approveKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation approveKpokWithHttpInfo
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ApproveKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApproveKpokResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApproveKpokResponse';
        $request = $this->approveKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApproveKpokResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approveKpokAsync
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ApproveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveKpokAsync($request = null)
    {
        return $this->approveKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveKpokAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Planowana\" na \"Zatwierdzona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ApproveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApproveKpokResponse';
        $request = $this->approveKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ApproveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function approveKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/approve/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignReceiveConfirmationToKpok
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1AssignReceiveConfirmationToKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1AssignReceiveConfirmationToKpokResponse
     */
    public function assignReceiveConfirmationToKpok($request = null)
    {
        list($response) = $this->assignReceiveConfirmationToKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation assignReceiveConfirmationToKpokWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1AssignReceiveConfirmationToKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1AssignReceiveConfirmationToKpokResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignReceiveConfirmationToKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1AssignReceiveConfirmationToKpokResponse';
        $request = $this->assignReceiveConfirmationToKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1AssignReceiveConfirmationToKpokResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation assignReceiveConfirmationToKpokAsync
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1AssignReceiveConfirmationToKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignReceiveConfirmationToKpokAsync($request = null)
    {
        return $this->assignReceiveConfirmationToKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignReceiveConfirmationToKpokAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie wygenerowane\" na \"Potwierdzenie przejęcia\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1AssignReceiveConfirmationToKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignReceiveConfirmationToKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1AssignReceiveConfirmationToKpokResponse';
        $request = $this->assignReceiveConfirmationToKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignReceiveConfirmationToKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1AssignReceiveConfirmationToKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assignReceiveConfirmationToKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/assign/receiveconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeKpokStatusToTransportConfirmation
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationResponse
     */
    public function changeKpokStatusToTransportConfirmation($request = null)
    {
        list($response) = $this->changeKpokStatusToTransportConfirmationWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation changeKpokStatusToTransportConfirmationWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeKpokStatusToTransportConfirmationWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationResponse';
        $request = $this->changeKpokStatusToTransportConfirmationRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeKpokStatusToTransportConfirmationAsync
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeKpokStatusToTransportConfirmationAsync($request = null)
    {
        return $this->changeKpokStatusToTransportConfirmationAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeKpokStatusToTransportConfirmationAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Potwierdzenie przejęcia\" na \"Potwierdzenie transportu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeKpokStatusToTransportConfirmationAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationResponse';
        $request = $this->changeKpokStatusToTransportConfirmationRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeKpokStatusToTransportConfirmation'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ChangeKpokStatusToTransportConfirmationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeKpokStatusToTransportConfirmationRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/status/transportconfirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKpok
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1DeleteKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKpok($request = null)
    {
        list($response) = $this->deleteKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKpokWithHttpInfo
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1DeleteKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKpokWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKpokAsync
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1DeleteKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKpokAsync($request = null)
    {
        return $this->deleteKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKpokAsyncWithHttpInfo
     *
     * Usunięcie karty ze statusem \"Planowana\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1DeleteKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1DeleteKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApprovedKpok
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApprovedKpokDto
     */
    public function getApprovedKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getApprovedKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getApprovedKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApprovedKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApprovedKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApprovedKpokDto';
        $request = $this->getApprovedKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApprovedKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApprovedKpokAsync
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovedKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getApprovedKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApprovedKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Zatwierdzona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovedKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ApprovedKpokDto';
        $request = $this->getApprovedKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApprovedKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApprovedKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/approved/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConfirmationGeneratedKpok
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ConfirmationGeneratedKpokDto
     */
    public function getConfirmationGeneratedKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getConfirmationGeneratedKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getConfirmationGeneratedKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ConfirmationGeneratedKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConfirmationGeneratedKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ConfirmationGeneratedKpokDto';
        $request = $this->getConfirmationGeneratedKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ConfirmationGeneratedKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConfirmationGeneratedKpokAsync
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConfirmationGeneratedKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getConfirmationGeneratedKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConfirmationGeneratedKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wygenerowane potwierdzenie\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConfirmationGeneratedKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ConfirmationGeneratedKpokDto';
        $request = $this->getConfirmationGeneratedKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConfirmationGeneratedKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConfirmationGeneratedKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/confirmationgenerated/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKpokReceivePrintingPage
     *
     * Pobranie danych karty przekazania do wydruku, dla podtypu \"Odbiór\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokReceivePrintingPage
     */
    public function getKpokReceivePrintingPage($kpok_id = null)
    {
        list($response) = $this->getKpokReceivePrintingPageWithHttpInfo($kpok_id);
        return $response;
    }

    /**
     * Operation getKpokReceivePrintingPageWithHttpInfo
     *
     * Pobranie danych karty przekazania do wydruku, dla podtypu \"Odbiór\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokReceivePrintingPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKpokReceivePrintingPageWithHttpInfo($kpok_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokReceivePrintingPage';
        $request = $this->getKpokReceivePrintingPageRequest($kpok_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokReceivePrintingPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKpokReceivePrintingPageAsync
     *
     * Pobranie danych karty przekazania do wydruku, dla podtypu \"Odbiór\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKpokReceivePrintingPageAsync($kpok_id = null)
    {
        return $this->getKpokReceivePrintingPageAsyncWithHttpInfo($kpok_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKpokReceivePrintingPageAsyncWithHttpInfo
     *
     * Pobranie danych karty przekazania do wydruku, dla podtypu \"Odbiór\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKpokReceivePrintingPageAsyncWithHttpInfo($kpok_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokReceivePrintingPage';
        $request = $this->getKpokReceivePrintingPageRequest($kpok_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKpokReceivePrintingPage'
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKpokReceivePrintingPageRequest($kpok_id = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/printingpage/receive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKpokTransferPrintingPage
     *
     * Pobranie danych karty do wydruku, dla podtypu \"Przekazanie\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokTransferPrintingPage
     */
    public function getKpokTransferPrintingPage($kpok_id = null)
    {
        list($response) = $this->getKpokTransferPrintingPageWithHttpInfo($kpok_id);
        return $response;
    }

    /**
     * Operation getKpokTransferPrintingPageWithHttpInfo
     *
     * Pobranie danych karty do wydruku, dla podtypu \"Przekazanie\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokTransferPrintingPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKpokTransferPrintingPageWithHttpInfo($kpok_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokTransferPrintingPage';
        $request = $this->getKpokTransferPrintingPageRequest($kpok_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokTransferPrintingPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKpokTransferPrintingPageAsync
     *
     * Pobranie danych karty do wydruku, dla podtypu \"Przekazanie\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKpokTransferPrintingPageAsync($kpok_id = null)
    {
        return $this->getKpokTransferPrintingPageAsyncWithHttpInfo($kpok_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKpokTransferPrintingPageAsyncWithHttpInfo
     *
     * Pobranie danych karty do wydruku, dla podtypu \"Przekazanie\"
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKpokTransferPrintingPageAsyncWithHttpInfo($kpok_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokTransferPrintingPage';
        $request = $this->getKpokTransferPrintingPageRequest($kpok_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKpokTransferPrintingPage'
     *
     * @param  string $kpok_id Id karty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKpokTransferPrintingPageRequest($kpok_id = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/printingpage/transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPlannedKpok
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedKpokDto
     */
    public function getPlannedKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getPlannedKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getPlannedKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPlannedKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedKpokDto';
        $request = $this->getPlannedKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPlannedKpokAsync
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlannedKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getPlannedKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPlannedKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Planowana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlannedKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedKpokDto';
        $request = $this->getPlannedKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPlannedKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPlannedKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/planned/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReceiveConfirmedKpok
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiveConfirmedKpokDto
     */
    public function getReceiveConfirmedKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getReceiveConfirmedKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getReceiveConfirmedKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiveConfirmedKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiveConfirmedKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiveConfirmedKpokDto';
        $request = $this->getReceiveConfirmedKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiveConfirmedKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiveConfirmedKpokAsync
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiveConfirmedKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getReceiveConfirmedKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiveConfirmedKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzenie przejęcia\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiveConfirmedKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiveConfirmedKpokDto';
        $request = $this->getReceiveConfirmedKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiveConfirmedKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReceiveConfirmedKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/receiveconfirmed/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRejectedKpok
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectedKpokDto
     */
    public function getRejectedKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getRejectedKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getRejectedKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectedKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRejectedKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectedKpokDto';
        $request = $this->getRejectedKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectedKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRejectedKpokAsync
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRejectedKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getRejectedKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRejectedKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Odrzucona\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRejectedKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectedKpokDto';
        $request = $this->getRejectedKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRejectedKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRejectedKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/rejected/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransportConfirmationKpok
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1TransportConfirmationKpokDto
     */
    public function getTransportConfirmationKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getTransportConfirmationKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getTransportConfirmationKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1TransportConfirmationKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransportConfirmationKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1TransportConfirmationKpokDto';
        $request = $this->getTransportConfirmationKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1TransportConfirmationKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransportConfirmationKpokAsync
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransportConfirmationKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getTransportConfirmationKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransportConfirmationKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Potwierdzony transport\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransportConfirmationKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1TransportConfirmationKpokDto';
        $request = $this->getTransportConfirmationKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransportConfirmationKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransportConfirmationKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/transportconfirmation/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWithdrawnKpok
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokDto
     */
    public function getWithdrawnKpok($kpok_id = null, $company_type = null)
    {
        list($response) = $this->getWithdrawnKpokWithHttpInfo($kpok_id, $company_type);
        return $response;
    }

    /**
     * Operation getWithdrawnKpokWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithdrawnKpokWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokDto';
        $request = $this->getWithdrawnKpokRequest($kpok_id, $company_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWithdrawnKpokAsync
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawnKpokAsync($kpok_id = null, $company_type = null)
    {
        return $this->getWithdrawnKpokAsyncWithHttpInfo($kpok_id, $company_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWithdrawnKpokAsyncWithHttpInfo
     *
     * Informacje o karcie ze statusem \"Wycofana\"
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawnKpokAsyncWithHttpInfo($kpok_id = null, $company_type = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokDto';
        $request = $this->getWithdrawnKpokRequest($kpok_id, $company_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWithdrawnKpok'
     *
     * @param  string $kpok_id Id karty (optional)
     * @param  string $company_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWithdrawnKpokRequest($kpok_id = null, $company_type = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/withdrawn/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kpok_id !== null) {
            $queryParams['KpokId'] = ObjectSerializer::toQueryValue($kpok_id);
        }
        // query params
        if ($company_type !== null) {
            $queryParams['CompanyType'] = ObjectSerializer::toQueryValue($company_type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation planReceiveKpok
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanReceiveKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedReceiveKpokDto
     */
    public function planReceiveKpok($request = null)
    {
        list($response) = $this->planReceiveKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation planReceiveKpokWithHttpInfo
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanReceiveKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedReceiveKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function planReceiveKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedReceiveKpokDto';
        $request = $this->planReceiveKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedReceiveKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation planReceiveKpokAsync
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planReceiveKpokAsync($request = null)
    {
        return $this->planReceiveKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation planReceiveKpokAsyncWithHttpInfo
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planReceiveKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedReceiveKpokDto';
        $request = $this->planReceiveKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'planReceiveKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function planReceiveKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/create/plannedreceivecard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation planTransferKpok
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanTransferKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedTransferKpokDto
     */
    public function planTransferKpok($request = null)
    {
        list($response) = $this->planTransferKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation planTransferKpokWithHttpInfo
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanTransferKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedTransferKpokDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function planTransferKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedTransferKpokDto';
        $request = $this->planTransferKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedTransferKpokDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation planTransferKpokAsync
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planTransferKpokAsync($request = null)
    {
        return $this->planTransferKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation planTransferKpokAsyncWithHttpInfo
     *
     * Tworzenie karty ze statusem \"Planowana\" dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planTransferKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PlannedTransferKpokDto';
        $request = $this->planTransferKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'planTransferKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PlanTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function planTransferKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/create/plannedtransfercard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation promoteKpokToConfirmationGenerated
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Wygenerowane potwierdzenie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedResponse
     */
    public function promoteKpokToConfirmationGenerated($request = null)
    {
        list($response) = $this->promoteKpokToConfirmationGeneratedWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation promoteKpokToConfirmationGeneratedWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Wygenerowane potwierdzenie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function promoteKpokToConfirmationGeneratedWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedResponse';
        $request = $this->promoteKpokToConfirmationGeneratedRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation promoteKpokToConfirmationGeneratedAsync
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Wygenerowane potwierdzenie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function promoteKpokToConfirmationGeneratedAsync($request = null)
    {
        return $this->promoteKpokToConfirmationGeneratedAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation promoteKpokToConfirmationGeneratedAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" na \"Wygenerowane potwierdzenie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function promoteKpokToConfirmationGeneratedAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedResponse';
        $request = $this->promoteKpokToConfirmationGeneratedRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'promoteKpokToConfirmationGenerated'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1PromoteKpokToConfirmationGeneratedRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function promoteKpokToConfirmationGeneratedRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/promote/confirmationgenerated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rejectKpok
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1RejectKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectKpokResponse
     */
    public function rejectKpok($request = null)
    {
        list($response) = $this->rejectKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation rejectKpokWithHttpInfo
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1RejectKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectKpokResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function rejectKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectKpokResponse';
        $request = $this->rejectKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectKpokResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rejectKpokAsync
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1RejectKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rejectKpokAsync($request = null)
    {
        return $this->rejectKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rejectKpokAsyncWithHttpInfo
     *
     * Zmiana statusu karty \"Potwierdzenie wygenerowane\" na \"Odrzucona\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1RejectKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rejectKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1RejectKpokResponse';
        $request = $this->rejectKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rejectKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1RejectKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rejectKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/reject/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviseKpok
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ReviseKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReviseKpokResponse
     */
    public function reviseKpok($request = null)
    {
        list($response) = $this->reviseKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation reviseKpokWithHttpInfo
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ReviseKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReviseKpokResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviseKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReviseKpokResponse';
        $request = $this->reviseKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReviseKpokResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviseKpokAsync
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ReviseKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviseKpokAsync($request = null)
    {
        return $this->reviseKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviseKpokAsyncWithHttpInfo
     *
     * Korekta odrzuconej karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ReviseKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviseKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReviseKpokResponse';
        $request = $this->reviseKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviseKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1ReviseKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviseKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/revise';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKpokAsCarrier
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsCarrierRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKpokAsCarrier($request = null)
    {
        list($response) = $this->searchKpokAsCarrierWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKpokAsCarrierWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsCarrierRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKpokAsCarrierWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpokAsCarrierRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKpokAsCarrierAsync
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpokAsCarrierAsync($request = null)
    {
        return $this->searchKpokAsCarrierAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKpokAsCarrierAsyncWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Transportującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpokAsCarrierAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsCarrierSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpokAsCarrierRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKpokAsCarrier'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsCarrierRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKpokAsCarrierRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/carrier/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKpokAsReceiver
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsReceiverRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKpokAsReceiver($request = null)
    {
        list($response) = $this->searchKpokAsReceiverWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKpokAsReceiverWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsReceiverRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKpokAsReceiverWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpokAsReceiverRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKpokAsReceiverAsync
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpokAsReceiverAsync($request = null)
    {
        return $this->searchKpokAsReceiverAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKpokAsReceiverAsyncWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przejmującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpokAsReceiverAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsReceiverSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpokAsReceiverRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKpokAsReceiver'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKpokAsReceiverRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/receiver/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKpokAsSender
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsSenderRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKpokAsSender($request = null)
    {
        list($response) = $this->searchKpokAsSenderWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKpokAsSenderWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsSenderRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKpokAsSenderWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpokAsSenderRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKpokAsSenderAsync
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpokAsSenderAsync($request = null)
    {
        return $this->searchKpokAsSenderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKpokAsSenderAsyncWithHttpInfo
     *
     * Wyszukiwarka kart, gdzie bieżący podmiot występuje w roli Przekazującego
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKpokAsSenderAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1KpokAsSenderSearchResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKpokAsSenderRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKpokAsSender'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchKpokAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKpokAsSenderRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/sender/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchReceiverKpokAsSender
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchReceiverKpokAsSenderRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiverKpokAsSenderListItem[]
     */
    public function searchReceiverKpokAsSender($request = null)
    {
        list($response) = $this->searchReceiverKpokAsSenderWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchReceiverKpokAsSenderWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchReceiverKpokAsSenderRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiverKpokAsSenderListItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchReceiverKpokAsSenderWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiverKpokAsSenderListItem[]';
        $request = $this->searchReceiverKpokAsSenderRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiverKpokAsSenderListItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchReceiverKpokAsSenderAsync
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchReceiverKpokAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchReceiverKpokAsSenderAsync($request = null)
    {
        return $this->searchReceiverKpokAsSenderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchReceiverKpokAsSenderAsyncWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przekazującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchReceiverKpokAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchReceiverKpokAsSenderAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1ReceiverKpokAsSenderListItem[]';
        $request = $this->searchReceiverKpokAsSenderRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchReceiverKpokAsSender'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchReceiverKpokAsSenderRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchReceiverKpokAsSenderRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/receivercards/sender';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchSenderKpokAsReceiver
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchSenderKpokAsReceiverRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1SenderKpokAsReceiverListItem[]
     */
    public function searchSenderKpokAsReceiver($request = null)
    {
        list($response) = $this->searchSenderKpokAsReceiverWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchSenderKpokAsReceiverWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchSenderKpokAsReceiverRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1SenderKpokAsReceiverListItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchSenderKpokAsReceiverWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1SenderKpokAsReceiverListItem[]';
        $request = $this->searchSenderKpokAsReceiverRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1SenderKpokAsReceiverListItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchSenderKpokAsReceiverAsync
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchSenderKpokAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSenderKpokAsReceiverAsync($request = null)
    {
        return $this->searchSenderKpokAsReceiverAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchSenderKpokAsReceiverAsyncWithHttpInfo
     *
     * Lista kart ze statusem \"Zrealizowane przejęcie\" lub \"Potwierdzony transport\", gdzie bieżący podmiot występuje w roli przejmującego odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchSenderKpokAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSenderKpokAsReceiverAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1SenderKpokAsReceiverListItem[]';
        $request = $this->searchSenderKpokAsReceiverRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchSenderKpokAsReceiver'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardSearchCardsV1SearchSenderKpokAsReceiverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchSenderKpokAsReceiverRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/sendercards/receiver';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApprovedReceiveKpok
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedReceiveKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateApprovedReceiveKpok($request = null)
    {
        list($response) = $this->updateApprovedReceiveKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateApprovedReceiveKpokWithHttpInfo
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedReceiveKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApprovedReceiveKpokWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedReceiveKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateApprovedReceiveKpokAsync
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedReceiveKpokAsync($request = null)
    {
        return $this->updateApprovedReceiveKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApprovedReceiveKpokAsyncWithHttpInfo
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedReceiveKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedReceiveKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApprovedReceiveKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateApprovedReceiveKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/update/approvedreceivecard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApprovedTransferKpok
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedTransferKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateApprovedTransferKpok($request = null)
    {
        list($response) = $this->updateApprovedTransferKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateApprovedTransferKpokWithHttpInfo
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedTransferKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApprovedTransferKpokWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedTransferKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateApprovedTransferKpokAsync
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedTransferKpokAsync($request = null)
    {
        return $this->updateApprovedTransferKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApprovedTransferKpokAsyncWithHttpInfo
     *
     * Edycja karty ze statusem \"Zatwierdzona\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateApprovedTransferKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateApprovedTransferKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApprovedTransferKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdateApprovedTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateApprovedTransferKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/update/approvedtransfercard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePlannedReceiveKpok
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedReceiveKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updatePlannedReceiveKpok($request = null)
    {
        list($response) = $this->updatePlannedReceiveKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updatePlannedReceiveKpokWithHttpInfo
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedReceiveKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePlannedReceiveKpokWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updatePlannedReceiveKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePlannedReceiveKpokAsync
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePlannedReceiveKpokAsync($request = null)
    {
        return $this->updatePlannedReceiveKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePlannedReceiveKpokAsyncWithHttpInfo
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Odbiór\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePlannedReceiveKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updatePlannedReceiveKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePlannedReceiveKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedReceiveKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePlannedReceiveKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/update/plannedreceivecard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePlannedTransferKpok
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedTransferKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updatePlannedTransferKpok($request = null)
    {
        list($response) = $this->updatePlannedTransferKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updatePlannedTransferKpokWithHttpInfo
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedTransferKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePlannedTransferKpokWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updatePlannedTransferKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePlannedTransferKpokAsync
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePlannedTransferKpokAsync($request = null)
    {
        return $this->updatePlannedTransferKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePlannedTransferKpokAsyncWithHttpInfo
     *
     * Edycja karty ze statusem \"Planowana\", dla podtypu \"Przekazanie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePlannedTransferKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updatePlannedTransferKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePlannedTransferKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1UpdatePlannedTransferKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePlannedTransferKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/update/plannedtransfercard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation withdrawnKpok
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1WithdrawnKpokRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokResponse
     */
    public function withdrawnKpok($request = null)
    {
        list($response) = $this->withdrawnKpokWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation withdrawnKpokWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1WithdrawnKpokRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function withdrawnKpokWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokResponse';
        $request = $this->withdrawnKpokRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation withdrawnKpokAsync
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1WithdrawnKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawnKpokAsync($request = null)
    {
        return $this->withdrawnKpokAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation withdrawnKpokAsyncWithHttpInfo
     *
     * Zmiana statusu karty z \"Zatwierdzona\" lub \"Potwierdzenie wygenerowane\" na \"Wycofana\".
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1WithdrawnKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function withdrawnKpokAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterMuncipalWasteTransferCardV1WithdrawnKpokResponse';
        $request = $this->withdrawnKpokRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'withdrawnKpok'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterMunicipalWasteTransferCardV1WithdrawnKpokRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function withdrawnKpokRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WasteTransferCard/v1/Kpok/card/withdrawn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
