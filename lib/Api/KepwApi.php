<?php
/**
 * KepwApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * v1 Waste Register public Api
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * KepwApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class KepwApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation checkWasteCodeUsedInKepwCreateContext
     *
     * Sprawdzenie czy istnieje już karta z danym kodem odpadu
     *
     * @param  int $waste_code_id waste_code_id (optional)
     * @param  bool $waste_code_extended waste_code_extended (optional)
     * @param  string $waste_code_extended_description waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse
     */
    public function checkWasteCodeUsedInKepwCreateContext($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        list($response) = $this->checkWasteCodeUsedInKepwCreateContextWithHttpInfo($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);
        return $response;
    }

    /**
     * Operation checkWasteCodeUsedInKepwCreateContextWithHttpInfo
     *
     * Sprawdzenie czy istnieje już karta z danym kodem odpadu
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkWasteCodeUsedInKepwCreateContextWithHttpInfo($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse';
        $request = $this->checkWasteCodeUsedInKepwCreateContextRequest($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkWasteCodeUsedInKepwCreateContextAsync
     *
     * Sprawdzenie czy istnieje już karta z danym kodem odpadu
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkWasteCodeUsedInKepwCreateContextAsync($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        return $this->checkWasteCodeUsedInKepwCreateContextAsyncWithHttpInfo($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkWasteCodeUsedInKepwCreateContextAsyncWithHttpInfo
     *
     * Sprawdzenie czy istnieje już karta z danym kodem odpadu
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkWasteCodeUsedInKepwCreateContextAsyncWithHttpInfo($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse';
        $request = $this->checkWasteCodeUsedInKepwCreateContextRequest($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkWasteCodeUsedInKepwCreateContext'
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkWasteCodeUsedInKepwCreateContextRequest($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/context/wastecodeCreate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($waste_code_id !== null) {
            $queryParams['WasteCodeId'] = ObjectSerializer::toQueryValue($waste_code_id);
        }
        // query params
        if ($waste_code_extended !== null) {
            $queryParams['WasteCodeExtended'] = ObjectSerializer::toQueryValue($waste_code_extended);
        }
        // query params
        if ($waste_code_extended_description !== null) {
            $queryParams['WasteCodeExtendedDescription'] = ObjectSerializer::toQueryValue($waste_code_extended_description);
        }
        // query params
        if ($hazardous_waste_reclassification !== null) {
            $queryParams['HazardousWasteReclassification'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification);
        }
        // query params
        if ($hazardous_waste_reclassification_description !== null) {
            $queryParams['HazardousWasteReclassificationDescription'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification_description);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkWasteCodeUsedInKepwEditContext
     *
     * Sprawdzenie czy oprócz wybranej karty istnieje inna z danym kodem odpadu
     *
     * @param  string $kepw_id kepw_id (optional)
     * @param  int $waste_code_id waste_code_id (optional)
     * @param  bool $waste_code_extended waste_code_extended (optional)
     * @param  string $waste_code_extended_description waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse
     */
    public function checkWasteCodeUsedInKepwEditContext($kepw_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        list($response) = $this->checkWasteCodeUsedInKepwEditContextWithHttpInfo($kepw_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);
        return $response;
    }

    /**
     * Operation checkWasteCodeUsedInKepwEditContextWithHttpInfo
     *
     * Sprawdzenie czy oprócz wybranej karty istnieje inna z danym kodem odpadu
     *
     * @param  string $kepw_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkWasteCodeUsedInKepwEditContextWithHttpInfo($kepw_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse';
        $request = $this->checkWasteCodeUsedInKepwEditContextRequest($kepw_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkWasteCodeUsedInKepwEditContextAsync
     *
     * Sprawdzenie czy oprócz wybranej karty istnieje inna z danym kodem odpadu
     *
     * @param  string $kepw_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkWasteCodeUsedInKepwEditContextAsync($kepw_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        return $this->checkWasteCodeUsedInKepwEditContextAsyncWithHttpInfo($kepw_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkWasteCodeUsedInKepwEditContextAsyncWithHttpInfo
     *
     * Sprawdzenie czy oprócz wybranej karty istnieje inna z danym kodem odpadu
     *
     * @param  string $kepw_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkWasteCodeUsedInKepwEditContextAsyncWithHttpInfo($kepw_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CheckWasteCodeUsedInKepwCreateContextResponse';
        $request = $this->checkWasteCodeUsedInKepwEditContextRequest($kepw_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkWasteCodeUsedInKepwEditContext'
     *
     * @param  string $kepw_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkWasteCodeUsedInKepwEditContextRequest($kepw_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/context/wastecodeEdit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kepw_id !== null) {
            $queryParams['KepwId'] = ObjectSerializer::toQueryValue($kepw_id);
        }
        // query params
        if ($waste_code_id !== null) {
            $queryParams['WasteCodeId'] = ObjectSerializer::toQueryValue($waste_code_id);
        }
        // query params
        if ($waste_code_extended !== null) {
            $queryParams['WasteCodeExtended'] = ObjectSerializer::toQueryValue($waste_code_extended);
        }
        // query params
        if ($waste_code_extended_description !== null) {
            $queryParams['WasteCodeExtendedDescription'] = ObjectSerializer::toQueryValue($waste_code_extended_description);
        }
        // query params
        if ($hazardous_waste_reclassification !== null) {
            $queryParams['HazardousWasteReclassification'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification);
        }
        // query params
        if ($hazardous_waste_reclassification_description !== null) {
            $queryParams['HazardousWasteReclassificationDescription'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification_description);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCollectingReceivedVehicle
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1CreateCollectingReceivedVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingReceivedVehicleResponse
     */
    public function createCollectingReceivedVehicle($request = null)
    {
        list($response) = $this->createCollectingReceivedVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createCollectingReceivedVehicleWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1CreateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingReceivedVehicleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCollectingReceivedVehicleWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingReceivedVehicleResponse';
        $request = $this->createCollectingReceivedVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingReceivedVehicleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCollectingReceivedVehicleAsync
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1CreateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectingReceivedVehicleAsync($request = null)
    {
        return $this->createCollectingReceivedVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCollectingReceivedVehicleAsyncWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1CreateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectingReceivedVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingReceivedVehicleResponse';
        $request = $this->createCollectingReceivedVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCollectingReceivedVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1CreateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCollectingReceivedVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCollectingTransferredVehicle
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1CreateCollectingTransferredVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingTransferredVehicleResponse
     */
    public function createCollectingTransferredVehicle($request = null)
    {
        list($response) = $this->createCollectingTransferredVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createCollectingTransferredVehicleWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1CreateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingTransferredVehicleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCollectingTransferredVehicleWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingTransferredVehicleResponse';
        $request = $this->createCollectingTransferredVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingTransferredVehicleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCollectingTransferredVehicleAsync
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1CreateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectingTransferredVehicleAsync($request = null)
    {
        return $this->createCollectingTransferredVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCollectingTransferredVehicleAsyncWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1CreateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectingTransferredVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateCollectingTransferredVehicleResponse';
        $request = $this->createCollectingTransferredVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCollectingTransferredVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1CreateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCollectingTransferredVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingTransferredVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDismantleProcessedWaste
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1CreateDismantleProcessedWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProcessedWasteResponse
     */
    public function createDismantleProcessedWaste($request = null)
    {
        list($response) = $this->createDismantleProcessedWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createDismantleProcessedWasteWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1CreateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProcessedWasteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDismantleProcessedWasteWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProcessedWasteResponse';
        $request = $this->createDismantleProcessedWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProcessedWasteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDismantleProcessedWasteAsync
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1CreateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleProcessedWasteAsync($request = null)
    {
        return $this->createDismantleProcessedWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDismantleProcessedWasteAsyncWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1CreateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleProcessedWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProcessedWasteResponse';
        $request = $this->createDismantleProcessedWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDismantleProcessedWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1CreateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDismantleProcessedWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProcessedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDismantleProducedWaste
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1CreateDismantleProducedWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProducedWasteResponse
     */
    public function createDismantleProducedWaste($request = null)
    {
        list($response) = $this->createDismantleProducedWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createDismantleProducedWasteWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1CreateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProducedWasteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDismantleProducedWasteWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProducedWasteResponse';
        $request = $this->createDismantleProducedWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProducedWasteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDismantleProducedWasteAsync
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1CreateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleProducedWasteAsync($request = null)
    {
        return $this->createDismantleProducedWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDismantleProducedWasteAsyncWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1CreateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleProducedWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleProducedWasteResponse';
        $request = $this->createDismantleProducedWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDismantleProducedWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1CreateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDismantleProducedWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProducedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDismantleReceivedVehicle
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1CreateDismantleReceivedVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReceivedVehicleResponse
     */
    public function createDismantleReceivedVehicle($request = null)
    {
        list($response) = $this->createDismantleReceivedVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createDismantleReceivedVehicleWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1CreateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReceivedVehicleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDismantleReceivedVehicleWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReceivedVehicleResponse';
        $request = $this->createDismantleReceivedVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReceivedVehicleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDismantleReceivedVehicleAsync
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1CreateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleReceivedVehicleAsync($request = null)
    {
        return $this->createDismantleReceivedVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDismantleReceivedVehicleAsyncWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1CreateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleReceivedVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReceivedVehicleResponse';
        $request = $this->createDismantleReceivedVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDismantleReceivedVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1CreateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDismantleReceivedVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDismantleReusableEquipmentAndParts
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1CreateDismantleReusableEquipmentAndPartsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReusableEquipmentAndPartsResponse
     */
    public function createDismantleReusableEquipmentAndParts($request = null)
    {
        list($response) = $this->createDismantleReusableEquipmentAndPartsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createDismantleReusableEquipmentAndPartsWithHttpInfo
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1CreateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReusableEquipmentAndPartsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDismantleReusableEquipmentAndPartsWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReusableEquipmentAndPartsResponse';
        $request = $this->createDismantleReusableEquipmentAndPartsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReusableEquipmentAndPartsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDismantleReusableEquipmentAndPartsAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1CreateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleReusableEquipmentAndPartsAsync($request = null)
    {
        return $this->createDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDismantleReusableEquipmentAndPartsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1CreateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleReusableEquipmentAndPartsResponse';
        $request = $this->createDismantleReusableEquipmentAndPartsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDismantleReusableEquipmentAndParts'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1CreateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDismantleReusableEquipmentAndPartsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReusableEquipmentAndParts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDismantleTransferredWaste
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1CreateDismantleTransferredWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleTransferredWasteResponse
     */
    public function createDismantleTransferredWaste($request = null)
    {
        list($response) = $this->createDismantleTransferredWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createDismantleTransferredWasteWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1CreateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleTransferredWasteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDismantleTransferredWasteWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleTransferredWasteResponse';
        $request = $this->createDismantleTransferredWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleTransferredWasteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDismantleTransferredWasteAsync
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1CreateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleTransferredWasteAsync($request = null)
    {
        return $this->createDismantleTransferredWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDismantleTransferredWasteAsyncWithHttpInfo
     *
     * Tworzenie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1CreateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDismantleTransferredWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateDismantleTransferredWasteResponse';
        $request = $this->createDismantleTransferredWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDismantleTransferredWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1CreateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDismantleTransferredWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleTransferredWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKepw
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1CreateKepwRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateKepwResponse
     */
    public function createKepw($request = null)
    {
        list($response) = $this->createKepwWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKepwWithHttpInfo
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1CreateKepwRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateKepwResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKepwWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateKepwResponse';
        $request = $this->createKepwRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateKepwResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKepwAsync
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1CreateKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKepwAsync($request = null)
    {
        return $this->createKepwAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKepwAsyncWithHttpInfo
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1CreateKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKepwAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1CreateKepwResponse';
        $request = $this->createKepwRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKepw'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1CreateKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKepwRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectingReceivedVehicle
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1DeleteCollectingReceivedVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteCollectingReceivedVehicle($request = null)
    {
        list($response) = $this->deleteCollectingReceivedVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteCollectingReceivedVehicleWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1DeleteCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectingReceivedVehicleWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteCollectingReceivedVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectingReceivedVehicleAsync
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1DeleteCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectingReceivedVehicleAsync($request = null)
    {
        return $this->deleteCollectingReceivedVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectingReceivedVehicleAsyncWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1DeleteCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectingReceivedVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteCollectingReceivedVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectingReceivedVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1DeleteCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectingReceivedVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectingTransferredVehicle
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1DeleteCollectingTransferredVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteCollectingTransferredVehicle($request = null)
    {
        list($response) = $this->deleteCollectingTransferredVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteCollectingTransferredVehicleWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1DeleteCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectingTransferredVehicleWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteCollectingTransferredVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectingTransferredVehicleAsync
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1DeleteCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectingTransferredVehicleAsync($request = null)
    {
        return $this->deleteCollectingTransferredVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectingTransferredVehicleAsyncWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1DeleteCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectingTransferredVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteCollectingTransferredVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectingTransferredVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1DeleteCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectingTransferredVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingTransferredVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDismantleProcessedWaste
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1DeleteDismantleProcessedWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteDismantleProcessedWaste($request = null)
    {
        list($response) = $this->deleteDismantleProcessedWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteDismantleProcessedWasteWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1DeleteDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDismantleProcessedWasteWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleProcessedWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDismantleProcessedWasteAsync
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1DeleteDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleProcessedWasteAsync($request = null)
    {
        return $this->deleteDismantleProcessedWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDismantleProcessedWasteAsyncWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1DeleteDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleProcessedWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleProcessedWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDismantleProcessedWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1DeleteDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDismantleProcessedWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProcessedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDismantleProducedWaste
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1DeleteDismantleProducedWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteDismantleProducedWaste($request = null)
    {
        list($response) = $this->deleteDismantleProducedWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteDismantleProducedWasteWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1DeleteDismantleProducedWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDismantleProducedWasteWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleProducedWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDismantleProducedWasteAsync
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1DeleteDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleProducedWasteAsync($request = null)
    {
        return $this->deleteDismantleProducedWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDismantleProducedWasteAsyncWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1DeleteDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleProducedWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleProducedWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDismantleProducedWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1DeleteDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDismantleProducedWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProducedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDismantleReceivedVehicle
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1DeleteDismantleReceivedVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteDismantleReceivedVehicle($request = null)
    {
        list($response) = $this->deleteDismantleReceivedVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteDismantleReceivedVehicleWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1DeleteDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDismantleReceivedVehicleWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleReceivedVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDismantleReceivedVehicleAsync
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1DeleteDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleReceivedVehicleAsync($request = null)
    {
        return $this->deleteDismantleReceivedVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDismantleReceivedVehicleAsyncWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1DeleteDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleReceivedVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleReceivedVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDismantleReceivedVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1DeleteDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDismantleReceivedVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDismantleReusableEquipmentAndParts
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1DeleteDismantleReusableEquipmentAndPartsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteDismantleReusableEquipmentAndParts($request = null)
    {
        list($response) = $this->deleteDismantleReusableEquipmentAndPartsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteDismantleReusableEquipmentAndPartsWithHttpInfo
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1DeleteDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDismantleReusableEquipmentAndPartsWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleReusableEquipmentAndPartsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDismantleReusableEquipmentAndPartsAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1DeleteDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleReusableEquipmentAndPartsAsync($request = null)
    {
        return $this->deleteDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDismantleReusableEquipmentAndPartsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1DeleteDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleReusableEquipmentAndPartsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDismantleReusableEquipmentAndParts'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1DeleteDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDismantleReusableEquipmentAndPartsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReusableEquipmentAndParts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDismantleTransferredWaste
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1DeleteDismantleTransferredWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteDismantleTransferredWaste($request = null)
    {
        list($response) = $this->deleteDismantleTransferredWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteDismantleTransferredWasteWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1DeleteDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDismantleTransferredWasteWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleTransferredWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDismantleTransferredWasteAsync
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1DeleteDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleTransferredWasteAsync($request = null)
    {
        return $this->deleteDismantleTransferredWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDismantleTransferredWasteAsyncWithHttpInfo
     *
     * Usunięcie wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1DeleteDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDismantleTransferredWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteDismantleTransferredWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDismantleTransferredWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1DeleteDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDismantleTransferredWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleTransferredWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKepw
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1DeleteKepwRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKepw($request = null)
    {
        list($response) = $this->deleteKepwWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKepwWithHttpInfo
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1DeleteKepwRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKepwWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKepwRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKepwAsync
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1DeleteKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKepwAsync($request = null)
    {
        return $this->deleteKepwAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKepwAsyncWithHttpInfo
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1DeleteKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKepwAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKepwRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKepw'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1DeleteKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKepwRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCollectingReceivedVehicle
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  string $collecting_received_vehicle_id collecting_received_vehicle_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehicleResponse
     */
    public function getCollectingReceivedVehicle($collecting_received_vehicle_id = null)
    {
        list($response) = $this->getCollectingReceivedVehicleWithHttpInfo($collecting_received_vehicle_id);
        return $response;
    }

    /**
     * Operation getCollectingReceivedVehicleWithHttpInfo
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  string $collecting_received_vehicle_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehicleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectingReceivedVehicleWithHttpInfo($collecting_received_vehicle_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehicleResponse';
        $request = $this->getCollectingReceivedVehicleRequest($collecting_received_vehicle_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehicleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCollectingReceivedVehicleAsync
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  string $collecting_received_vehicle_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingReceivedVehicleAsync($collecting_received_vehicle_id = null)
    {
        return $this->getCollectingReceivedVehicleAsyncWithHttpInfo($collecting_received_vehicle_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectingReceivedVehicleAsyncWithHttpInfo
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  string $collecting_received_vehicle_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingReceivedVehicleAsyncWithHttpInfo($collecting_received_vehicle_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehicleResponse';
        $request = $this->getCollectingReceivedVehicleRequest($collecting_received_vehicle_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCollectingReceivedVehicle'
     *
     * @param  string $collecting_received_vehicle_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectingReceivedVehicleRequest($collecting_received_vehicle_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($collecting_received_vehicle_id !== null) {
            $queryParams['CollectingReceivedVehicleId'] = ObjectSerializer::toQueryValue($collecting_received_vehicle_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCollectingReceivedVehicles
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1GetCollectingReceivedVehiclesRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehiclesResponse
     */
    public function getCollectingReceivedVehicles($request = null)
    {
        list($response) = $this->getCollectingReceivedVehiclesWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getCollectingReceivedVehiclesWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1GetCollectingReceivedVehiclesRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehiclesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectingReceivedVehiclesWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehiclesResponse';
        $request = $this->getCollectingReceivedVehiclesRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehiclesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCollectingReceivedVehiclesAsync
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1GetCollectingReceivedVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingReceivedVehiclesAsync($request = null)
    {
        return $this->getCollectingReceivedVehiclesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectingReceivedVehiclesAsyncWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1GetCollectingReceivedVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingReceivedVehiclesAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingReceivedVehiclesResponse';
        $request = $this->getCollectingReceivedVehiclesRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCollectingReceivedVehicles'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1GetCollectingReceivedVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectingReceivedVehiclesRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingReceivedVehicle/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCollectingTransferredVehicle
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  string $collecting_transferred_vehicles_id collecting_transferred_vehicles_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehicleResponse
     */
    public function getCollectingTransferredVehicle($collecting_transferred_vehicles_id = null)
    {
        list($response) = $this->getCollectingTransferredVehicleWithHttpInfo($collecting_transferred_vehicles_id);
        return $response;
    }

    /**
     * Operation getCollectingTransferredVehicleWithHttpInfo
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  string $collecting_transferred_vehicles_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehicleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectingTransferredVehicleWithHttpInfo($collecting_transferred_vehicles_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehicleResponse';
        $request = $this->getCollectingTransferredVehicleRequest($collecting_transferred_vehicles_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehicleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCollectingTransferredVehicleAsync
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  string $collecting_transferred_vehicles_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingTransferredVehicleAsync($collecting_transferred_vehicles_id = null)
    {
        return $this->getCollectingTransferredVehicleAsyncWithHttpInfo($collecting_transferred_vehicles_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectingTransferredVehicleAsyncWithHttpInfo
     *
     * Informacje o wpisie Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  string $collecting_transferred_vehicles_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingTransferredVehicleAsyncWithHttpInfo($collecting_transferred_vehicles_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehicleResponse';
        $request = $this->getCollectingTransferredVehicleRequest($collecting_transferred_vehicles_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCollectingTransferredVehicle'
     *
     * @param  string $collecting_transferred_vehicles_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectingTransferredVehicleRequest($collecting_transferred_vehicles_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingTransferredVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($collecting_transferred_vehicles_id !== null) {
            $queryParams['CollectingTransferredVehiclesId'] = ObjectSerializer::toQueryValue($collecting_transferred_vehicles_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCollectingTransferredVehicles
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1GetCollectingTransferredVehiclesRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehiclesResponse
     */
    public function getCollectingTransferredVehicles($request = null)
    {
        list($response) = $this->getCollectingTransferredVehiclesWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getCollectingTransferredVehiclesWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1GetCollectingTransferredVehiclesRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehiclesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectingTransferredVehiclesWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehiclesResponse';
        $request = $this->getCollectingTransferredVehiclesRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehiclesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCollectingTransferredVehiclesAsync
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1GetCollectingTransferredVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingTransferredVehiclesAsync($request = null)
    {
        return $this->getCollectingTransferredVehiclesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectingTransferredVehiclesAsyncWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1GetCollectingTransferredVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectingTransferredVehiclesAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingTransferredVehiclesResponse';
        $request = $this->getCollectingTransferredVehiclesRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCollectingTransferredVehicles'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1GetCollectingTransferredVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectingTransferredVehiclesRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingTransferredVehicle/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleProcessedWaste
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  string $dismantle_processed_waste_id dismantle_processed_waste_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWasteResponse
     */
    public function getDismantleProcessedWaste($dismantle_processed_waste_id = null)
    {
        list($response) = $this->getDismantleProcessedWasteWithHttpInfo($dismantle_processed_waste_id);
        return $response;
    }

    /**
     * Operation getDismantleProcessedWasteWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  string $dismantle_processed_waste_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWasteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleProcessedWasteWithHttpInfo($dismantle_processed_waste_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWasteResponse';
        $request = $this->getDismantleProcessedWasteRequest($dismantle_processed_waste_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWasteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleProcessedWasteAsync
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  string $dismantle_processed_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProcessedWasteAsync($dismantle_processed_waste_id = null)
    {
        return $this->getDismantleProcessedWasteAsyncWithHttpInfo($dismantle_processed_waste_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleProcessedWasteAsyncWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  string $dismantle_processed_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProcessedWasteAsyncWithHttpInfo($dismantle_processed_waste_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWasteResponse';
        $request = $this->getDismantleProcessedWasteRequest($dismantle_processed_waste_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleProcessedWaste'
     *
     * @param  string $dismantle_processed_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleProcessedWasteRequest($dismantle_processed_waste_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProcessedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dismantle_processed_waste_id !== null) {
            $queryParams['DismantleProcessedWasteId'] = ObjectSerializer::toQueryValue($dismantle_processed_waste_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleProcessedWastes
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1GetDismantleProcessedWastesRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWastesResponse
     */
    public function getDismantleProcessedWastes($request = null)
    {
        list($response) = $this->getDismantleProcessedWastesWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getDismantleProcessedWastesWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1GetDismantleProcessedWastesRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWastesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleProcessedWastesWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWastesResponse';
        $request = $this->getDismantleProcessedWastesRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWastesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleProcessedWastesAsync
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1GetDismantleProcessedWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProcessedWastesAsync($request = null)
    {
        return $this->getDismantleProcessedWastesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleProcessedWastesAsyncWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1GetDismantleProcessedWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProcessedWastesAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProcessedWastesResponse';
        $request = $this->getDismantleProcessedWastesRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleProcessedWastes'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1GetDismantleProcessedWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleProcessedWastesRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProcessedWaste/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleProducedWaste
     *
     * Informacje o wpisie Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  string $dismantle_produced_waste_id dismantle_produced_waste_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWasteResponse
     */
    public function getDismantleProducedWaste($dismantle_produced_waste_id = null)
    {
        list($response) = $this->getDismantleProducedWasteWithHttpInfo($dismantle_produced_waste_id);
        return $response;
    }

    /**
     * Operation getDismantleProducedWasteWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  string $dismantle_produced_waste_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWasteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleProducedWasteWithHttpInfo($dismantle_produced_waste_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWasteResponse';
        $request = $this->getDismantleProducedWasteRequest($dismantle_produced_waste_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWasteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleProducedWasteAsync
     *
     * Informacje o wpisie Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  string $dismantle_produced_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProducedWasteAsync($dismantle_produced_waste_id = null)
    {
        return $this->getDismantleProducedWasteAsyncWithHttpInfo($dismantle_produced_waste_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleProducedWasteAsyncWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  string $dismantle_produced_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProducedWasteAsyncWithHttpInfo($dismantle_produced_waste_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWasteResponse';
        $request = $this->getDismantleProducedWasteRequest($dismantle_produced_waste_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleProducedWaste'
     *
     * @param  string $dismantle_produced_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleProducedWasteRequest($dismantle_produced_waste_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProducedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dismantle_produced_waste_id !== null) {
            $queryParams['DismantleProducedWasteId'] = ObjectSerializer::toQueryValue($dismantle_produced_waste_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleProducedWastes
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1GetDismantleProducedWastesRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWastesResponse
     */
    public function getDismantleProducedWastes($request = null)
    {
        list($response) = $this->getDismantleProducedWastesWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getDismantleProducedWastesWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1GetDismantleProducedWastesRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWastesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleProducedWastesWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWastesResponse';
        $request = $this->getDismantleProducedWastesRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWastesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleProducedWastesAsync
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1GetDismantleProducedWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProducedWastesAsync($request = null)
    {
        return $this->getDismantleProducedWastesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleProducedWastesAsyncWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1GetDismantleProducedWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleProducedWastesAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleProducedWastesResponse';
        $request = $this->getDismantleProducedWastesRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleProducedWastes'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1GetDismantleProducedWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleProducedWastesRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProducedWaste/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleReceivedVehicle
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  string $dismantle_received_vehicle_id dismantle_received_vehicle_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehicleResponse
     */
    public function getDismantleReceivedVehicle($dismantle_received_vehicle_id = null)
    {
        list($response) = $this->getDismantleReceivedVehicleWithHttpInfo($dismantle_received_vehicle_id);
        return $response;
    }

    /**
     * Operation getDismantleReceivedVehicleWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  string $dismantle_received_vehicle_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehicleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleReceivedVehicleWithHttpInfo($dismantle_received_vehicle_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehicleResponse';
        $request = $this->getDismantleReceivedVehicleRequest($dismantle_received_vehicle_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehicleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleReceivedVehicleAsync
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  string $dismantle_received_vehicle_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReceivedVehicleAsync($dismantle_received_vehicle_id = null)
    {
        return $this->getDismantleReceivedVehicleAsyncWithHttpInfo($dismantle_received_vehicle_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleReceivedVehicleAsyncWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  string $dismantle_received_vehicle_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReceivedVehicleAsyncWithHttpInfo($dismantle_received_vehicle_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehicleResponse';
        $request = $this->getDismantleReceivedVehicleRequest($dismantle_received_vehicle_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleReceivedVehicle'
     *
     * @param  string $dismantle_received_vehicle_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleReceivedVehicleRequest($dismantle_received_vehicle_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dismantle_received_vehicle_id !== null) {
            $queryParams['DismantleReceivedVehicleId'] = ObjectSerializer::toQueryValue($dismantle_received_vehicle_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleReceivedVehicles
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1GetDismantleReceivedVehiclesRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehiclesResponse
     */
    public function getDismantleReceivedVehicles($request = null)
    {
        list($response) = $this->getDismantleReceivedVehiclesWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getDismantleReceivedVehiclesWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1GetDismantleReceivedVehiclesRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehiclesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleReceivedVehiclesWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehiclesResponse';
        $request = $this->getDismantleReceivedVehiclesRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehiclesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleReceivedVehiclesAsync
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1GetDismantleReceivedVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReceivedVehiclesAsync($request = null)
    {
        return $this->getDismantleReceivedVehiclesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleReceivedVehiclesAsyncWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1GetDismantleReceivedVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReceivedVehiclesAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReceivedVehiclesResponse';
        $request = $this->getDismantleReceivedVehiclesRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleReceivedVehicles'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1GetDismantleReceivedVehiclesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleReceivedVehiclesRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReceivedVehicle/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleReusableEquipmentAndParts
     *
     * @param  string $dismantle_reusable_equipment_and_parts_id dismantle_reusable_equipment_and_parts_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsResponse
     */
    public function getDismantleReusableEquipmentAndParts($dismantle_reusable_equipment_and_parts_id = null)
    {
        list($response) = $this->getDismantleReusableEquipmentAndPartsWithHttpInfo($dismantle_reusable_equipment_and_parts_id);
        return $response;
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsWithHttpInfo
     *
     * @param  string $dismantle_reusable_equipment_and_parts_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleReusableEquipmentAndPartsWithHttpInfo($dismantle_reusable_equipment_and_parts_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsResponse';
        $request = $this->getDismantleReusableEquipmentAndPartsRequest($dismantle_reusable_equipment_and_parts_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsAsync
     *
     * 
     *
     * @param  string $dismantle_reusable_equipment_and_parts_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReusableEquipmentAndPartsAsync($dismantle_reusable_equipment_and_parts_id = null)
    {
        return $this->getDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($dismantle_reusable_equipment_and_parts_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $dismantle_reusable_equipment_and_parts_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($dismantle_reusable_equipment_and_parts_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsResponse';
        $request = $this->getDismantleReusableEquipmentAndPartsRequest($dismantle_reusable_equipment_and_parts_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleReusableEquipmentAndParts'
     *
     * @param  string $dismantle_reusable_equipment_and_parts_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleReusableEquipmentAndPartsRequest($dismantle_reusable_equipment_and_parts_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReusableEquipmentAndParts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dismantle_reusable_equipment_and_parts_id !== null) {
            $queryParams['dismantleReusableEquipmentAndPartsId'] = ObjectSerializer::toQueryValue($dismantle_reusable_equipment_and_parts_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsList
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1GetDismantleReusableEquipmentAndPartsListRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsListResponse
     */
    public function getDismantleReusableEquipmentAndPartsList($request = null)
    {
        list($response) = $this->getDismantleReusableEquipmentAndPartsListWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsListWithHttpInfo
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1GetDismantleReusableEquipmentAndPartsListRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleReusableEquipmentAndPartsListWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsListResponse';
        $request = $this->getDismantleReusableEquipmentAndPartsListRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsListAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1GetDismantleReusableEquipmentAndPartsListRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReusableEquipmentAndPartsListAsync($request = null)
    {
        return $this->getDismantleReusableEquipmentAndPartsListAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleReusableEquipmentAndPartsListAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1GetDismantleReusableEquipmentAndPartsListRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleReusableEquipmentAndPartsListAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleReusableEquipmentAndPartsListResponse';
        $request = $this->getDismantleReusableEquipmentAndPartsListRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleReusableEquipmentAndPartsList'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1GetDismantleReusableEquipmentAndPartsListRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleReusableEquipmentAndPartsListRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReusableEquipmentAndParts/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleTransferredWaste
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  string $dismantle_transferred_waste_id dismantle_transferred_waste_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWasteResponse
     */
    public function getDismantleTransferredWaste($dismantle_transferred_waste_id = null)
    {
        list($response) = $this->getDismantleTransferredWasteWithHttpInfo($dismantle_transferred_waste_id);
        return $response;
    }

    /**
     * Operation getDismantleTransferredWasteWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  string $dismantle_transferred_waste_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWasteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleTransferredWasteWithHttpInfo($dismantle_transferred_waste_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWasteResponse';
        $request = $this->getDismantleTransferredWasteRequest($dismantle_transferred_waste_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWasteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleTransferredWasteAsync
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  string $dismantle_transferred_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleTransferredWasteAsync($dismantle_transferred_waste_id = null)
    {
        return $this->getDismantleTransferredWasteAsyncWithHttpInfo($dismantle_transferred_waste_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleTransferredWasteAsyncWithHttpInfo
     *
     * Informacje o wpisie Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  string $dismantle_transferred_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleTransferredWasteAsyncWithHttpInfo($dismantle_transferred_waste_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWasteResponse';
        $request = $this->getDismantleTransferredWasteRequest($dismantle_transferred_waste_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleTransferredWaste'
     *
     * @param  string $dismantle_transferred_waste_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleTransferredWasteRequest($dismantle_transferred_waste_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleTransferredWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dismantle_transferred_waste_id !== null) {
            $queryParams['DismantleTransferredWasteId'] = ObjectSerializer::toQueryValue($dismantle_transferred_waste_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleTransferredWastes
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1GetDismantleTransferredWastesRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWastesResponse
     */
    public function getDismantleTransferredWastes($request = null)
    {
        list($response) = $this->getDismantleTransferredWastesWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation getDismantleTransferredWastesWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1GetDismantleTransferredWastesRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWastesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleTransferredWastesWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWastesResponse';
        $request = $this->getDismantleTransferredWastesRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWastesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleTransferredWastesAsync
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1GetDismantleTransferredWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleTransferredWastesAsync($request = null)
    {
        return $this->getDismantleTransferredWastesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleTransferredWastesAsyncWithHttpInfo
     *
     * Wyszukiwarka wpisów Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1GetDismantleTransferredWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleTransferredWastesAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleTransferredWastesResponse';
        $request = $this->getDismantleTransferredWastesRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleTransferredWastes'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1GetDismantleTransferredWastesRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleTransferredWastesRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleTransferredWaste/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDismantleWasteSummary
     *
     * Zestawienie danych - Prowadzący stację demontażu
     *
     * @param  string $kepw_id kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleWasteSummaryResponse
     */
    public function getDismantleWasteSummary($kepw_id = null)
    {
        list($response) = $this->getDismantleWasteSummaryWithHttpInfo($kepw_id);
        return $response;
    }

    /**
     * Operation getDismantleWasteSummaryWithHttpInfo
     *
     * Zestawienie danych - Prowadzący stację demontażu
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleWasteSummaryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDismantleWasteSummaryWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleWasteSummaryResponse';
        $request = $this->getDismantleWasteSummaryRequest($kepw_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleWasteSummaryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDismantleWasteSummaryAsync
     *
     * Zestawienie danych - Prowadzący stację demontażu
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleWasteSummaryAsync($kepw_id = null)
    {
        return $this->getDismantleWasteSummaryAsyncWithHttpInfo($kepw_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDismantleWasteSummaryAsyncWithHttpInfo
     *
     * Zestawienie danych - Prowadzący stację demontażu
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDismantleWasteSummaryAsyncWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantleWasteSummaryResponse';
        $request = $this->getDismantleWasteSummaryRequest($kepw_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDismantleWasteSummary'
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDismantleWasteSummaryRequest($kepw_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleWasteSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kepw_id !== null) {
            $queryParams['KepwId'] = ObjectSerializer::toQueryValue($kepw_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKepw
     *
     * Informacje o karcie i liście stanów magazynowych - odpady
     *
     * @param  string $kepw_id kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwWithDismantleInitialWastes
     */
    public function getKepw($kepw_id = null)
    {
        list($response) = $this->getKepwWithHttpInfo($kepw_id);
        return $response;
    }

    /**
     * Operation getKepwWithHttpInfo
     *
     * Informacje o karcie i liście stanów magazynowych - odpady
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwWithDismantleInitialWastes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKepwWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwWithDismantleInitialWastes';
        $request = $this->getKepwRequest($kepw_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwWithDismantleInitialWastes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKepwAsync
     *
     * Informacje o karcie i liście stanów magazynowych - odpady
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKepwAsync($kepw_id = null)
    {
        return $this->getKepwAsyncWithHttpInfo($kepw_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKepwAsyncWithHttpInfo
     *
     * Informacje o karcie i liście stanów magazynowych - odpady
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKepwAsyncWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwWithDismantleInitialWastes';
        $request = $this->getKepwRequest($kepw_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKepw'
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKepwRequest($kepw_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kepw_id !== null) {
            $queryParams['KepwId'] = ObjectSerializer::toQueryValue($kepw_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKepwCollectingPrintingPage
     *
     * Pobranie danych karty do wydruku - Prowadzący punkt zbierania pojazdów
     *
     * @param  string $kepw_id kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingPrintingPageResponse
     */
    public function getKepwCollectingPrintingPage($kepw_id = null)
    {
        list($response) = $this->getKepwCollectingPrintingPageWithHttpInfo($kepw_id);
        return $response;
    }

    /**
     * Operation getKepwCollectingPrintingPageWithHttpInfo
     *
     * Pobranie danych karty do wydruku - Prowadzący punkt zbierania pojazdów
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingPrintingPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKepwCollectingPrintingPageWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingPrintingPageResponse';
        $request = $this->getKepwCollectingPrintingPageRequest($kepw_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingPrintingPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKepwCollectingPrintingPageAsync
     *
     * Pobranie danych karty do wydruku - Prowadzący punkt zbierania pojazdów
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKepwCollectingPrintingPageAsync($kepw_id = null)
    {
        return $this->getKepwCollectingPrintingPageAsyncWithHttpInfo($kepw_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKepwCollectingPrintingPageAsyncWithHttpInfo
     *
     * Pobranie danych karty do wydruku - Prowadzący punkt zbierania pojazdów
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKepwCollectingPrintingPageAsyncWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetCollectingPrintingPageResponse';
        $request = $this->getKepwCollectingPrintingPageRequest($kepw_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKepwCollectingPrintingPage'
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKepwCollectingPrintingPageRequest($kepw_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/card/collecting/printingpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kepw_id !== null) {
            $queryParams['KepwId'] = ObjectSerializer::toQueryValue($kepw_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKepwDismantlePrintingPage
     *
     * Pobranie danych karty do wydruku - Prowadzący stację demontażu
     *
     * @param  string $kepw_id kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantlePrintingPageResponse
     */
    public function getKepwDismantlePrintingPage($kepw_id = null)
    {
        list($response) = $this->getKepwDismantlePrintingPageWithHttpInfo($kepw_id);
        return $response;
    }

    /**
     * Operation getKepwDismantlePrintingPageWithHttpInfo
     *
     * Pobranie danych karty do wydruku - Prowadzący stację demontażu
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantlePrintingPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKepwDismantlePrintingPageWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantlePrintingPageResponse';
        $request = $this->getKepwDismantlePrintingPageRequest($kepw_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantlePrintingPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKepwDismantlePrintingPageAsync
     *
     * Pobranie danych karty do wydruku - Prowadzący stację demontażu
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKepwDismantlePrintingPageAsync($kepw_id = null)
    {
        return $this->getKepwDismantlePrintingPageAsyncWithHttpInfo($kepw_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKepwDismantlePrintingPageAsyncWithHttpInfo
     *
     * Pobranie danych karty do wydruku - Prowadzący stację demontażu
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKepwDismantlePrintingPageAsyncWithHttpInfo($kepw_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1GetDismantlePrintingPageResponse';
        $request = $this->getKepwDismantlePrintingPageRequest($kepw_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKepwDismantlePrintingPage'
     *
     * @param  string $kepw_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKepwDismantlePrintingPageRequest($kepw_id = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/card/dismantle/printingpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kepw_id !== null) {
            $queryParams['KepwId'] = ObjectSerializer::toQueryValue($kepw_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKepw
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1SearchKepwRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwListItemWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKepw($request = null)
    {
        list($response) = $this->searchKepwWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKepwWithHttpInfo
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1SearchKepwRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwListItemWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKepwWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwListItemWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKepwRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwListItemWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKepwAsync
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1SearchKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKepwAsync($request = null)
    {
        return $this->searchKepwAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKepwAsyncWithHttpInfo
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1SearchKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKepwAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterWreckWasteRecordCardV1KepwListItemWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKepwRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKepw'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1SearchKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKepwRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCollectingReceivedVehicle
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1UpdateCollectingReceivedVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateCollectingReceivedVehicle($request = null)
    {
        list($response) = $this->updateCollectingReceivedVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateCollectingReceivedVehicleWithHttpInfo
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1UpdateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCollectingReceivedVehicleWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateCollectingReceivedVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCollectingReceivedVehicleAsync
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1UpdateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCollectingReceivedVehicleAsync($request = null)
    {
        return $this->updateCollectingReceivedVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCollectingReceivedVehicleAsyncWithHttpInfo
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przyjęte
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1UpdateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCollectingReceivedVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateCollectingReceivedVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCollectingReceivedVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingReceivedVehicleV1UpdateCollectingReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCollectingReceivedVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCollectingTransferredVehicle
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1UpdateCollectingTransferredVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateCollectingTransferredVehicle($request = null)
    {
        list($response) = $this->updateCollectingTransferredVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateCollectingTransferredVehicleWithHttpInfo
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1UpdateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCollectingTransferredVehicleWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateCollectingTransferredVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCollectingTransferredVehicleAsync
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1UpdateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCollectingTransferredVehicleAsync($request = null)
    {
        return $this->updateCollectingTransferredVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCollectingTransferredVehicleAsyncWithHttpInfo
     *
     * Edycja wpisu Prowadzący punkt zbierania pojazdów - Przekazane
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1UpdateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCollectingTransferredVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateCollectingTransferredVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCollectingTransferredVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardCollectingTransferredVehicleV1UpdateCollectingTransferredVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCollectingTransferredVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/collectingTransferredVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDismantleProcessedWaste
     *
     * Edycja wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1UpdateDismantleProcessedWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDismantleProcessedWaste($request = null)
    {
        list($response) = $this->updateDismantleProcessedWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateDismantleProcessedWasteWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1UpdateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDismantleProcessedWasteWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleProcessedWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDismantleProcessedWasteAsync
     *
     * Edycja wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1UpdateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleProcessedWasteAsync($request = null)
    {
        return $this->updateDismantleProcessedWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDismantleProcessedWasteAsyncWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Przetwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1UpdateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleProcessedWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleProcessedWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDismantleProcessedWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProcessedWasteV1UpdateDismantleProcessedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDismantleProcessedWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProcessedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDismantleProducedWaste
     *
     * Edycja wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1UpdateDismantleProducedWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDismantleProducedWaste($request = null)
    {
        list($response) = $this->updateDismantleProducedWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateDismantleProducedWasteWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1UpdateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDismantleProducedWasteWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleProducedWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDismantleProducedWasteAsync
     *
     * Edycja wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1UpdateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleProducedWasteAsync($request = null)
    {
        return $this->updateDismantleProducedWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDismantleProducedWasteAsyncWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Wytwarzane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1UpdateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleProducedWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleProducedWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDismantleProducedWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleProducedWasteV1UpdateDismantleProducedWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDismantleProducedWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleProducedWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDismantleReceivedVehicle
     *
     * Edycja wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1UpdateDismantleReceivedVehicleRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDismantleReceivedVehicle($request = null)
    {
        list($response) = $this->updateDismantleReceivedVehicleWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateDismantleReceivedVehicleWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1UpdateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDismantleReceivedVehicleWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleReceivedVehicleRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDismantleReceivedVehicleAsync
     *
     * Edycja wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1UpdateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleReceivedVehicleAsync($request = null)
    {
        return $this->updateDismantleReceivedVehicleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDismantleReceivedVehicleAsyncWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Przyjete pojazdy
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1UpdateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleReceivedVehicleAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleReceivedVehicleRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDismantleReceivedVehicle'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReceivedVehicleV1UpdateDismantleReceivedVehicleRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDismantleReceivedVehicleRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReceivedVehicle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDismantleReusableEquipmentAndParts
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1UpdateDismantleReusableEquipmentAndPartsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDismantleReusableEquipmentAndParts($request = null)
    {
        list($response) = $this->updateDismantleReusableEquipmentAndPartsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateDismantleReusableEquipmentAndPartsWithHttpInfo
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1UpdateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDismantleReusableEquipmentAndPartsWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleReusableEquipmentAndPartsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDismantleReusableEquipmentAndPartsAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1UpdateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleReusableEquipmentAndPartsAsync($request = null)
    {
        return $this->updateDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDismantleReusableEquipmentAndPartsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1UpdateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleReusableEquipmentAndPartsAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleReusableEquipmentAndPartsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDismantleReusableEquipmentAndParts'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleReusableEquipmentAndPartsV1UpdateDismantleReusableEquipmentAndPartsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDismantleReusableEquipmentAndPartsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleReusableEquipmentAndParts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDismantleTransferredWaste
     *
     * Edycja wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1UpdateDismantleTransferredWasteRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDismantleTransferredWaste($request = null)
    {
        list($response) = $this->updateDismantleTransferredWasteWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateDismantleTransferredWasteWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1UpdateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDismantleTransferredWasteWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleTransferredWasteRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDismantleTransferredWasteAsync
     *
     * Edycja wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1UpdateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleTransferredWasteAsync($request = null)
    {
        return $this->updateDismantleTransferredWasteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDismantleTransferredWasteAsyncWithHttpInfo
     *
     * Edycja wpisu Prowadzący stację demontażu - Przekazane odpady
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1UpdateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDismantleTransferredWasteAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateDismantleTransferredWasteRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDismantleTransferredWaste'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardDismantleTransferredWasteV1UpdateDismantleTransferredWasteRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDismantleTransferredWasteRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw/dismantleTransferredWaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKepw
     *
     * Edycja karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1UpdateKepwRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKepw($request = null)
    {
        list($response) = $this->updateKepwWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKepwWithHttpInfo
     *
     * Edycja karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1UpdateKepwRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKepwWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKepwRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKepwAsync
     *
     * Edycja karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1UpdateKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKepwAsync($request = null)
    {
        return $this->updateKepwAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKepwAsyncWithHttpInfo
     *
     * Edycja karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1UpdateKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKepwAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKepwRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKepw'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterWreckWasteRecordCardKepwV1UpdateKepwRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKepwRequest($request = null)
    {

        $resourcePath = '/WasteRegister/WreckWasteRecordCard/v1/Kepw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
