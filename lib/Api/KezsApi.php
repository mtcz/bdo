<?php
/**
 * KezsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * v1 Waste Register public Api
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * KezsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class KezsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeCreate
     *
     * Sprawdzenie czy w danym roku istnieje już karta z wybranym kodem odpadu
     *
     * @param  int $waste_code_id waste_code_id (optional)
     * @param  bool $waste_code_extended waste_code_extended (optional)
     * @param  string $waste_code_extended_description waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeCreateResponse
     */
    public function checkKezsExistsByYearAndWasteCodeCreate($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        list($response) = $this->checkKezsExistsByYearAndWasteCodeCreateWithHttpInfo($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);
        return $response;
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeCreateWithHttpInfo
     *
     * Sprawdzenie czy w danym roku istnieje już karta z wybranym kodem odpadu
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeCreateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkKezsExistsByYearAndWasteCodeCreateWithHttpInfo($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeCreateResponse';
        $request = $this->checkKezsExistsByYearAndWasteCodeCreateRequest($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeCreateAsync
     *
     * Sprawdzenie czy w danym roku istnieje już karta z wybranym kodem odpadu
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkKezsExistsByYearAndWasteCodeCreateAsync($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        return $this->checkKezsExistsByYearAndWasteCodeCreateAsyncWithHttpInfo($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeCreateAsyncWithHttpInfo
     *
     * Sprawdzenie czy w danym roku istnieje już karta z wybranym kodem odpadu
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkKezsExistsByYearAndWasteCodeCreateAsyncWithHttpInfo($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeCreateResponse';
        $request = $this->checkKezsExistsByYearAndWasteCodeCreateRequest($waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkKezsExistsByYearAndWasteCodeCreate'
     *
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkKezsExistsByYearAndWasteCodeCreateRequest($waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/card/exist/year/wastecodeCreate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($waste_code_id !== null) {
            $queryParams['WasteCodeId'] = ObjectSerializer::toQueryValue($waste_code_id);
        }
        // query params
        if ($waste_code_extended !== null) {
            $queryParams['WasteCodeExtended'] = ObjectSerializer::toQueryValue($waste_code_extended);
        }
        // query params
        if ($waste_code_extended_description !== null) {
            $queryParams['WasteCodeExtendedDescription'] = ObjectSerializer::toQueryValue($waste_code_extended_description);
        }
        // query params
        if ($hazardous_waste_reclassification !== null) {
            $queryParams['HazardousWasteReclassification'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification);
        }
        // query params
        if ($hazardous_waste_reclassification_description !== null) {
            $queryParams['HazardousWasteReclassificationDescription'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification_description);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeEdit
     *
     * Sprawdzenie czy w danym roku oprócz wybranej karty istnieje inna z wybranym kodem odpadu
     *
     * @param  string $kezs_id kezs_id (optional)
     * @param  int $waste_code_id waste_code_id (optional)
     * @param  bool $waste_code_extended waste_code_extended (optional)
     * @param  string $waste_code_extended_description waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeEditResponse
     */
    public function checkKezsExistsByYearAndWasteCodeEdit($kezs_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        list($response) = $this->checkKezsExistsByYearAndWasteCodeEditWithHttpInfo($kezs_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);
        return $response;
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeEditWithHttpInfo
     *
     * Sprawdzenie czy w danym roku oprócz wybranej karty istnieje inna z wybranym kodem odpadu
     *
     * @param  string $kezs_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeEditResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkKezsExistsByYearAndWasteCodeEditWithHttpInfo($kezs_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeEditResponse';
        $request = $this->checkKezsExistsByYearAndWasteCodeEditRequest($kezs_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeEditResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeEditAsync
     *
     * Sprawdzenie czy w danym roku oprócz wybranej karty istnieje inna z wybranym kodem odpadu
     *
     * @param  string $kezs_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkKezsExistsByYearAndWasteCodeEditAsync($kezs_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        return $this->checkKezsExistsByYearAndWasteCodeEditAsyncWithHttpInfo($kezs_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkKezsExistsByYearAndWasteCodeEditAsyncWithHttpInfo
     *
     * Sprawdzenie czy w danym roku oprócz wybranej karty istnieje inna z wybranym kodem odpadu
     *
     * @param  string $kezs_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkKezsExistsByYearAndWasteCodeEditAsyncWithHttpInfo($kezs_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1CheckKezsExistsByYearAndWasteCodeEditResponse';
        $request = $this->checkKezsExistsByYearAndWasteCodeEditRequest($kezs_id, $waste_code_id, $waste_code_extended, $waste_code_extended_description, $hazardous_waste_reclassification, $hazardous_waste_reclassification_description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkKezsExistsByYearAndWasteCodeEdit'
     *
     * @param  string $kezs_id (optional)
     * @param  int $waste_code_id (optional)
     * @param  bool $waste_code_extended (optional)
     * @param  string $waste_code_extended_description (optional)
     * @param  bool $hazardous_waste_reclassification (optional)
     * @param  string $hazardous_waste_reclassification_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkKezsExistsByYearAndWasteCodeEditRequest($kezs_id = null, $waste_code_id = null, $waste_code_extended = null, $waste_code_extended_description = null, $hazardous_waste_reclassification = null, $hazardous_waste_reclassification_description = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/card/exist/year/wastecodeEdit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_id !== null) {
            $queryParams['KezsId'] = ObjectSerializer::toQueryValue($kezs_id);
        }
        // query params
        if ($waste_code_id !== null) {
            $queryParams['WasteCodeId'] = ObjectSerializer::toQueryValue($waste_code_id);
        }
        // query params
        if ($waste_code_extended !== null) {
            $queryParams['WasteCodeExtended'] = ObjectSerializer::toQueryValue($waste_code_extended);
        }
        // query params
        if ($waste_code_extended_description !== null) {
            $queryParams['WasteCodeExtendedDescription'] = ObjectSerializer::toQueryValue($waste_code_extended_description);
        }
        // query params
        if ($hazardous_waste_reclassification !== null) {
            $queryParams['HazardousWasteReclassification'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification);
        }
        // query params
        if ($hazardous_waste_reclassification_description !== null) {
            $queryParams['HazardousWasteReclassificationDescription'] = ObjectSerializer::toQueryValue($hazardous_waste_reclassification_description);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezs
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsDto
     */
    public function createKezs($request = null)
    {
        list($response) = $this->createKezsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsWithHttpInfo
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsDto';
        $request = $this->createKezsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsAsync
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsAsync($request = null)
    {
        return $this->createKezsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsAsyncWithHttpInfo
     *
     * Tworzenie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsDto';
        $request = $this->createKezsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezs'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezsEquipmentCollectingEntry
     *
     * Tworzenie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentCollectingEntryRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto
     */
    public function createKezsEquipmentCollectingEntry($request = null)
    {
        list($response) = $this->createKezsEquipmentCollectingEntryWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsEquipmentCollectingEntryWithHttpInfo
     *
     * Tworzenie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsEquipmentCollectingEntryWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto';
        $request = $this->createKezsEquipmentCollectingEntryRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsEquipmentCollectingEntryAsync
     *
     * Tworzenie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsEquipmentCollectingEntryAsync($request = null)
    {
        return $this->createKezsEquipmentCollectingEntryAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsEquipmentCollectingEntryAsyncWithHttpInfo
     *
     * Tworzenie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsEquipmentCollectingEntryAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto';
        $request = $this->createKezsEquipmentCollectingEntryRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezsEquipmentCollectingEntry'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsEquipmentCollectingEntryRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentCollectingEntry/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezsEquipmentManagement
     *
     * Tworzenie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentManagementRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto
     */
    public function createKezsEquipmentManagement($request = null)
    {
        list($response) = $this->createKezsEquipmentManagementWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsEquipmentManagementWithHttpInfo
     *
     * Tworzenie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsEquipmentManagementWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto';
        $request = $this->createKezsEquipmentManagementRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsEquipmentManagementAsync
     *
     * Tworzenie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsEquipmentManagementAsync($request = null)
    {
        return $this->createKezsEquipmentManagementAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsEquipmentManagementAsyncWithHttpInfo
     *
     * Tworzenie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsEquipmentManagementAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto';
        $request = $this->createKezsEquipmentManagementRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezsEquipmentManagement'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsEquipmentManagementRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentManagement/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezsStockWasteMassGroup
     *
     * Tworzenie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsStockWasteMassGroupRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto
     */
    public function createKezsStockWasteMassGroup($request = null)
    {
        list($response) = $this->createKezsStockWasteMassGroupWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsStockWasteMassGroupWithHttpInfo
     *
     * Tworzenie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsStockWasteMassGroupWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto';
        $request = $this->createKezsStockWasteMassGroupRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsStockWasteMassGroupAsync
     *
     * Tworzenie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsStockWasteMassGroupAsync($request = null)
    {
        return $this->createKezsStockWasteMassGroupAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsStockWasteMassGroupAsyncWithHttpInfo
     *
     * Tworzenie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsStockWasteMassGroupAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto';
        $request = $this->createKezsStockWasteMassGroupRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezsStockWasteMassGroup'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsStockWasteMassGroupRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsStockWasteMassGroup/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezsUsedEquipmentWasteGeneration
     *
     * Tworzenie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsUsedEquipmentWasteGenerationRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto
     */
    public function createKezsUsedEquipmentWasteGeneration($request = null)
    {
        list($response) = $this->createKezsUsedEquipmentWasteGenerationWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsUsedEquipmentWasteGenerationWithHttpInfo
     *
     * Tworzenie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsUsedEquipmentWasteGenerationWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto';
        $request = $this->createKezsUsedEquipmentWasteGenerationRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsUsedEquipmentWasteGenerationAsync
     *
     * Tworzenie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsUsedEquipmentWasteGenerationAsync($request = null)
    {
        return $this->createKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo
     *
     * Tworzenie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto';
        $request = $this->createKezsUsedEquipmentWasteGenerationRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezsUsedEquipmentWasteGeneration'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsUsedEquipmentWasteGenerationRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsUsedEquipmentWasteGeneration/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezsWasteManagementHandedOver
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementHandedOverRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto
     */
    public function createKezsWasteManagementHandedOver($request = null)
    {
        list($response) = $this->createKezsWasteManagementHandedOverWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsWasteManagementHandedOverWithHttpInfo
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsWasteManagementHandedOverWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto';
        $request = $this->createKezsWasteManagementHandedOverRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsWasteManagementHandedOverAsync
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsWasteManagementHandedOverAsync($request = null)
    {
        return $this->createKezsWasteManagementHandedOverAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsWasteManagementHandedOverAsyncWithHttpInfo
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsWasteManagementHandedOverAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto';
        $request = $this->createKezsWasteManagementHandedOverRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezsWasteManagementHandedOver'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsWasteManagementHandedOverRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementHandedOver/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKezsWasteManagementOnOnesOwn
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementOnOnesOwnRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto
     */
    public function createKezsWasteManagementOnOnesOwn($request = null)
    {
        list($response) = $this->createKezsWasteManagementOnOnesOwnWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation createKezsWasteManagementOnOnesOwnWithHttpInfo
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKezsWasteManagementOnOnesOwnWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto';
        $request = $this->createKezsWasteManagementOnOnesOwnRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKezsWasteManagementOnOnesOwnAsync
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsWasteManagementOnOnesOwnAsync($request = null)
    {
        return $this->createKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKezsWasteManagementOnOnesOwnAsyncWithHttpInfo
     *
     * Tworzenie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto';
        $request = $this->createKezsWasteManagementOnOnesOwnRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKezsWasteManagementOnOnesOwn'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1CreateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createKezsWasteManagementOnOnesOwnRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementOnOnesOwn/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezs
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezs($request = null)
    {
        list($response) = $this->deleteKezsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsWithHttpInfo
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsAsync
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsAsync($request = null)
    {
        return $this->deleteKezsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsAsyncWithHttpInfo
     *
     * Usunięcie karty
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezs'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezsEquipmentCollectingEntry
     *
     * Usunięcie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentCollectingEntryRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezsEquipmentCollectingEntry($request = null)
    {
        list($response) = $this->deleteKezsEquipmentCollectingEntryWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsEquipmentCollectingEntryWithHttpInfo
     *
     * Usunięcie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsEquipmentCollectingEntryWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsEquipmentCollectingEntryRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsEquipmentCollectingEntryAsync
     *
     * Usunięcie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsEquipmentCollectingEntryAsync($request = null)
    {
        return $this->deleteKezsEquipmentCollectingEntryAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsEquipmentCollectingEntryAsyncWithHttpInfo
     *
     * Usunięcie wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsEquipmentCollectingEntryAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsEquipmentCollectingEntryRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezsEquipmentCollectingEntry'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsEquipmentCollectingEntryRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentCollectingEntry/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezsEquipmentManagement
     *
     * Usunięcie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentManagementRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezsEquipmentManagement($request = null)
    {
        list($response) = $this->deleteKezsEquipmentManagementWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsEquipmentManagementWithHttpInfo
     *
     * Usunięcie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsEquipmentManagementWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsEquipmentManagementRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsEquipmentManagementAsync
     *
     * Usunięcie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsEquipmentManagementAsync($request = null)
    {
        return $this->deleteKezsEquipmentManagementAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsEquipmentManagementAsyncWithHttpInfo
     *
     * Usunięcie wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsEquipmentManagementAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsEquipmentManagementRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezsEquipmentManagement'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsEquipmentManagementRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentManagement/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezsStockWasteMassGroup
     *
     * Usunięcie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsStockWasteMassGroupRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezsStockWasteMassGroup($request = null)
    {
        list($response) = $this->deleteKezsStockWasteMassGroupWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsStockWasteMassGroupWithHttpInfo
     *
     * Usunięcie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsStockWasteMassGroupWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsStockWasteMassGroupRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsStockWasteMassGroupAsync
     *
     * Usunięcie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsStockWasteMassGroupAsync($request = null)
    {
        return $this->deleteKezsStockWasteMassGroupAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsStockWasteMassGroupAsyncWithHttpInfo
     *
     * Usunięcie wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsStockWasteMassGroupAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsStockWasteMassGroupRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezsStockWasteMassGroup'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsStockWasteMassGroupRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsStockWasteMassGroup/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezsUsedEquipmentWasteGeneration
     *
     * Usunięcie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsUsedEquipmentWasteGenerationRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezsUsedEquipmentWasteGeneration($request = null)
    {
        list($response) = $this->deleteKezsUsedEquipmentWasteGenerationWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsUsedEquipmentWasteGenerationWithHttpInfo
     *
     * Usunięcie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsUsedEquipmentWasteGenerationWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsUsedEquipmentWasteGenerationRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsUsedEquipmentWasteGenerationAsync
     *
     * Usunięcie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsUsedEquipmentWasteGenerationAsync($request = null)
    {
        return $this->deleteKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo
     *
     * Usunięcie wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsUsedEquipmentWasteGenerationRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezsUsedEquipmentWasteGeneration'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsUsedEquipmentWasteGenerationRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsUsedEquipmentWasteGeneration/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezsWasteManagementHandedOver
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementHandedOverRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezsWasteManagementHandedOver($request = null)
    {
        list($response) = $this->deleteKezsWasteManagementHandedOverWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsWasteManagementHandedOverWithHttpInfo
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsWasteManagementHandedOverWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsWasteManagementHandedOverRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsWasteManagementHandedOverAsync
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsWasteManagementHandedOverAsync($request = null)
    {
        return $this->deleteKezsWasteManagementHandedOverAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsWasteManagementHandedOverAsyncWithHttpInfo
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsWasteManagementHandedOverAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsWasteManagementHandedOverRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezsWasteManagementHandedOver'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsWasteManagementHandedOverRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementHandedOver/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteKezsWasteManagementOnOnesOwn
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementOnOnesOwnRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteKezsWasteManagementOnOnesOwn($request = null)
    {
        list($response) = $this->deleteKezsWasteManagementOnOnesOwnWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation deleteKezsWasteManagementOnOnesOwnWithHttpInfo
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteKezsWasteManagementOnOnesOwnWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsWasteManagementOnOnesOwnRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteKezsWasteManagementOnOnesOwnAsync
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsWasteManagementOnOnesOwnAsync($request = null)
    {
        return $this->deleteKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteKezsWasteManagementOnOnesOwnAsyncWithHttpInfo
     *
     * Usunięcie wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->deleteKezsWasteManagementOnOnesOwnRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteKezsWasteManagementOnOnesOwn'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1DeleteKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteKezsWasteManagementOnOnesOwnRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementOnOnesOwn/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezs
     *
     * Lista kart
     *
     * @param  string $kezs_id kezs_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsResponse
     */
    public function getKezs($kezs_id = null)
    {
        list($response) = $this->getKezsWithHttpInfo($kezs_id);
        return $response;
    }

    /**
     * Operation getKezsWithHttpInfo
     *
     * Lista kart
     *
     * @param  string $kezs_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsWithHttpInfo($kezs_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsResponse';
        $request = $this->getKezsRequest($kezs_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsAsync
     *
     * Lista kart
     *
     * @param  string $kezs_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsAsync($kezs_id = null)
    {
        return $this->getKezsAsyncWithHttpInfo($kezs_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsAsyncWithHttpInfo
     *
     * Lista kart
     *
     * @param  string $kezs_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsAsyncWithHttpInfo($kezs_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsResponse';
        $request = $this->getKezsRequest($kezs_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezs'
     *
     * @param  string $kezs_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsRequest($kezs_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_id !== null) {
            $queryParams['KezsId'] = ObjectSerializer::toQueryValue($kezs_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsEquipmentCollectingEntries
     *
     * Lista wpisów \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto[]
     */
    public function getKezsEquipmentCollectingEntries($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        list($response) = $this->getKezsEquipmentCollectingEntriesWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);
        return $response;
    }

    /**
     * Operation getKezsEquipmentCollectingEntriesWithHttpInfo
     *
     * Lista wpisów \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsEquipmentCollectingEntriesWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto[]';
        $request = $this->getKezsEquipmentCollectingEntriesRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsEquipmentCollectingEntriesAsync
     *
     * Lista wpisów \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsEquipmentCollectingEntriesAsync($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        return $this->getKezsEquipmentCollectingEntriesAsyncWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsEquipmentCollectingEntriesAsyncWithHttpInfo
     *
     * Lista wpisów \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsEquipmentCollectingEntriesAsyncWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto[]';
        $request = $this->getKezsEquipmentCollectingEntriesRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsEquipmentCollectingEntries'
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsEquipmentCollectingEntriesRequest($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentCollectingEntry/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_equipment_group_card_id !== null) {
            $queryParams['KezsEquipmentGroupCardId'] = ObjectSerializer::toQueryValue($kezs_equipment_group_card_id);
        }
        // query params
        if ($pagination_parameters_order_is_ascending !== null) {
            $queryParams['PaginationParameters.Order.IsAscending'] = ObjectSerializer::toQueryValue($pagination_parameters_order_is_ascending);
        }
        // query params
        if ($pagination_parameters_order_order_column !== null) {
            $queryParams['PaginationParameters.Order.OrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_order_order_column);
        }
        // query params
        if ($pagination_parameters_page_index !== null) {
            $queryParams['PaginationParameters.Page.Index'] = ObjectSerializer::toQueryValue($pagination_parameters_page_index);
        }
        // query params
        if ($pagination_parameters_page_size !== null) {
            $queryParams['PaginationParameters.Page.Size'] = ObjectSerializer::toQueryValue($pagination_parameters_page_size);
        }
        // query params
        if ($pagination_parameters_get_order_column !== null) {
            $queryParams['PaginationParameters.GetOrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_column);
        }
        // query params
        if ($pagination_parameters_get_order_direction !== null) {
            $queryParams['PaginationParameters.GetOrderDirection'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_direction);
        }
        // query params
        if ($pagination_parameters_get_ordering !== null) {
            $queryParams['PaginationParameters.GetOrdering'] = ObjectSerializer::toQueryValue($pagination_parameters_get_ordering);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsEquipmentCollectingEntry
     *
     * Informacje o wpisie \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_collecting_entry_id kezs_equipment_collecting_entry_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto
     */
    public function getKezsEquipmentCollectingEntry($kezs_equipment_collecting_entry_id = null)
    {
        list($response) = $this->getKezsEquipmentCollectingEntryWithHttpInfo($kezs_equipment_collecting_entry_id);
        return $response;
    }

    /**
     * Operation getKezsEquipmentCollectingEntryWithHttpInfo
     *
     * Informacje o wpisie \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_collecting_entry_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsEquipmentCollectingEntryWithHttpInfo($kezs_equipment_collecting_entry_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto';
        $request = $this->getKezsEquipmentCollectingEntryRequest($kezs_equipment_collecting_entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsEquipmentCollectingEntryAsync
     *
     * Informacje o wpisie \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_collecting_entry_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsEquipmentCollectingEntryAsync($kezs_equipment_collecting_entry_id = null)
    {
        return $this->getKezsEquipmentCollectingEntryAsyncWithHttpInfo($kezs_equipment_collecting_entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsEquipmentCollectingEntryAsyncWithHttpInfo
     *
     * Informacje o wpisie \"Zbieranie sprzętu\"
     *
     * @param  string $kezs_equipment_collecting_entry_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsEquipmentCollectingEntryAsyncWithHttpInfo($kezs_equipment_collecting_entry_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentCollectingEntryDto';
        $request = $this->getKezsEquipmentCollectingEntryRequest($kezs_equipment_collecting_entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsEquipmentCollectingEntry'
     *
     * @param  string $kezs_equipment_collecting_entry_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsEquipmentCollectingEntryRequest($kezs_equipment_collecting_entry_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentCollectingEntry/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_equipment_collecting_entry_id !== null) {
            $queryParams['KezsEquipmentCollectingEntryId'] = ObjectSerializer::toQueryValue($kezs_equipment_collecting_entry_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsEquipmentManagement
     *
     * Informacje o wpisie \"Gospodarowanie sprzętem\"
     *
     * @param  string $kezs_equipment_management_id kezs_equipment_management_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto
     */
    public function getKezsEquipmentManagement($kezs_equipment_management_id = null)
    {
        list($response) = $this->getKezsEquipmentManagementWithHttpInfo($kezs_equipment_management_id);
        return $response;
    }

    /**
     * Operation getKezsEquipmentManagementWithHttpInfo
     *
     * Informacje o wpisie \"Gospodarowanie sprzętem\"
     *
     * @param  string $kezs_equipment_management_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsEquipmentManagementWithHttpInfo($kezs_equipment_management_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto';
        $request = $this->getKezsEquipmentManagementRequest($kezs_equipment_management_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsEquipmentManagementAsync
     *
     * Informacje o wpisie \"Gospodarowanie sprzętem\"
     *
     * @param  string $kezs_equipment_management_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsEquipmentManagementAsync($kezs_equipment_management_id = null)
    {
        return $this->getKezsEquipmentManagementAsyncWithHttpInfo($kezs_equipment_management_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsEquipmentManagementAsyncWithHttpInfo
     *
     * Informacje o wpisie \"Gospodarowanie sprzętem\"
     *
     * @param  string $kezs_equipment_management_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsEquipmentManagementAsyncWithHttpInfo($kezs_equipment_management_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsEquipmentManagementDto';
        $request = $this->getKezsEquipmentManagementRequest($kezs_equipment_management_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsEquipmentManagement'
     *
     * @param  string $kezs_equipment_management_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsEquipmentManagementRequest($kezs_equipment_management_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsEquipmentManagement/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_equipment_management_id !== null) {
            $queryParams['KezsEquipmentManagementId'] = ObjectSerializer::toQueryValue($kezs_equipment_management_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsPrintingPageData
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kezs_id kezs_id (optional)
     * @param  int $group_number group_number (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsPrintingPageDataResponse
     */
    public function getKezsPrintingPageData($kezs_id = null, $group_number = null)
    {
        list($response) = $this->getKezsPrintingPageDataWithHttpInfo($kezs_id, $group_number);
        return $response;
    }

    /**
     * Operation getKezsPrintingPageDataWithHttpInfo
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kezs_id (optional)
     * @param  int $group_number (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsPrintingPageDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsPrintingPageDataWithHttpInfo($kezs_id = null, $group_number = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsPrintingPageDataResponse';
        $request = $this->getKezsPrintingPageDataRequest($kezs_id, $group_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsPrintingPageDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsPrintingPageDataAsync
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kezs_id (optional)
     * @param  int $group_number (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsPrintingPageDataAsync($kezs_id = null, $group_number = null)
    {
        return $this->getKezsPrintingPageDataAsyncWithHttpInfo($kezs_id, $group_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsPrintingPageDataAsyncWithHttpInfo
     *
     * Pobranie danych karty do wydruku
     *
     * @param  string $kezs_id (optional)
     * @param  int $group_number (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsPrintingPageDataAsyncWithHttpInfo($kezs_id = null, $group_number = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1GetKezsPrintingPageDataResponse';
        $request = $this->getKezsPrintingPageDataRequest($kezs_id, $group_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsPrintingPageData'
     *
     * @param  string $kezs_id (optional)
     * @param  int $group_number (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsPrintingPageDataRequest($kezs_id = null, $group_number = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/card/printingpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_id !== null) {
            $queryParams['KezsId'] = ObjectSerializer::toQueryValue($kezs_id);
        }
        // query params
        if ($group_number !== null) {
            $queryParams['GroupNumber'] = ObjectSerializer::toQueryValue($group_number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsStockWasteMassGroup
     *
     * Informacje o stanach magazynowych
     *
     * @param  string $kezs_stock_waste_mass_group_id kezs_stock_waste_mass_group_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto
     */
    public function getKezsStockWasteMassGroup($kezs_stock_waste_mass_group_id = null)
    {
        list($response) = $this->getKezsStockWasteMassGroupWithHttpInfo($kezs_stock_waste_mass_group_id);
        return $response;
    }

    /**
     * Operation getKezsStockWasteMassGroupWithHttpInfo
     *
     * Informacje o stanach magazynowych
     *
     * @param  string $kezs_stock_waste_mass_group_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsStockWasteMassGroupWithHttpInfo($kezs_stock_waste_mass_group_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto';
        $request = $this->getKezsStockWasteMassGroupRequest($kezs_stock_waste_mass_group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsStockWasteMassGroupAsync
     *
     * Informacje o stanach magazynowych
     *
     * @param  string $kezs_stock_waste_mass_group_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsStockWasteMassGroupAsync($kezs_stock_waste_mass_group_id = null)
    {
        return $this->getKezsStockWasteMassGroupAsyncWithHttpInfo($kezs_stock_waste_mass_group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsStockWasteMassGroupAsyncWithHttpInfo
     *
     * Informacje o stanach magazynowych
     *
     * @param  string $kezs_stock_waste_mass_group_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsStockWasteMassGroupAsyncWithHttpInfo($kezs_stock_waste_mass_group_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsStockWasteMassGroupDto';
        $request = $this->getKezsStockWasteMassGroupRequest($kezs_stock_waste_mass_group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsStockWasteMassGroup'
     *
     * @param  string $kezs_stock_waste_mass_group_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsStockWasteMassGroupRequest($kezs_stock_waste_mass_group_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/Kezs/KezsStockWasteMassGroup/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_stock_waste_mass_group_id !== null) {
            $queryParams['KezsStockWasteMassGroupId'] = ObjectSerializer::toQueryValue($kezs_stock_waste_mass_group_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationOver
     *
     * Informacje o wpisie \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_used_equipment_waste_generation_id kezs_used_equipment_waste_generation_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto
     */
    public function getKezsUsedEquipmentWasteGenerationOver($kezs_used_equipment_waste_generation_id = null)
    {
        list($response) = $this->getKezsUsedEquipmentWasteGenerationOverWithHttpInfo($kezs_used_equipment_waste_generation_id);
        return $response;
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationOverWithHttpInfo
     *
     * Informacje o wpisie \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_used_equipment_waste_generation_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsUsedEquipmentWasteGenerationOverWithHttpInfo($kezs_used_equipment_waste_generation_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto';
        $request = $this->getKezsUsedEquipmentWasteGenerationOverRequest($kezs_used_equipment_waste_generation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationOverAsync
     *
     * Informacje o wpisie \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_used_equipment_waste_generation_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsUsedEquipmentWasteGenerationOverAsync($kezs_used_equipment_waste_generation_id = null)
    {
        return $this->getKezsUsedEquipmentWasteGenerationOverAsyncWithHttpInfo($kezs_used_equipment_waste_generation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationOverAsyncWithHttpInfo
     *
     * Informacje o wpisie \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_used_equipment_waste_generation_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsUsedEquipmentWasteGenerationOverAsyncWithHttpInfo($kezs_used_equipment_waste_generation_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto';
        $request = $this->getKezsUsedEquipmentWasteGenerationOverRequest($kezs_used_equipment_waste_generation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsUsedEquipmentWasteGenerationOver'
     *
     * @param  string $kezs_used_equipment_waste_generation_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsUsedEquipmentWasteGenerationOverRequest($kezs_used_equipment_waste_generation_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsUsedEquipmentWasteGeneration/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_used_equipment_waste_generation_id !== null) {
            $queryParams['KezsUsedEquipmentWasteGenerationId'] = ObjectSerializer::toQueryValue($kezs_used_equipment_waste_generation_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerations
     *
     * Lista wpisów \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto[]
     */
    public function getKezsUsedEquipmentWasteGenerations($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        list($response) = $this->getKezsUsedEquipmentWasteGenerationsWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);
        return $response;
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationsWithHttpInfo
     *
     * Lista wpisów \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsUsedEquipmentWasteGenerationsWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto[]';
        $request = $this->getKezsUsedEquipmentWasteGenerationsRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationsAsync
     *
     * Lista wpisów \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsUsedEquipmentWasteGenerationsAsync($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        return $this->getKezsUsedEquipmentWasteGenerationsAsyncWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsUsedEquipmentWasteGenerationsAsyncWithHttpInfo
     *
     * Lista wpisów \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsUsedEquipmentWasteGenerationsAsyncWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsUsedEquipmentWasteGenerationDto[]';
        $request = $this->getKezsUsedEquipmentWasteGenerationsRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsUsedEquipmentWasteGenerations'
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsUsedEquipmentWasteGenerationsRequest($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsUsedEquipmentWasteGeneration/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_equipment_group_card_id !== null) {
            $queryParams['KezsEquipmentGroupCardId'] = ObjectSerializer::toQueryValue($kezs_equipment_group_card_id);
        }
        // query params
        if ($pagination_parameters_order_is_ascending !== null) {
            $queryParams['PaginationParameters.Order.IsAscending'] = ObjectSerializer::toQueryValue($pagination_parameters_order_is_ascending);
        }
        // query params
        if ($pagination_parameters_order_order_column !== null) {
            $queryParams['PaginationParameters.Order.OrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_order_order_column);
        }
        // query params
        if ($pagination_parameters_page_index !== null) {
            $queryParams['PaginationParameters.Page.Index'] = ObjectSerializer::toQueryValue($pagination_parameters_page_index);
        }
        // query params
        if ($pagination_parameters_page_size !== null) {
            $queryParams['PaginationParameters.Page.Size'] = ObjectSerializer::toQueryValue($pagination_parameters_page_size);
        }
        // query params
        if ($pagination_parameters_get_order_column !== null) {
            $queryParams['PaginationParameters.GetOrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_column);
        }
        // query params
        if ($pagination_parameters_get_order_direction !== null) {
            $queryParams['PaginationParameters.GetOrderDirection'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_direction);
        }
        // query params
        if ($pagination_parameters_get_ordering !== null) {
            $queryParams['PaginationParameters.GetOrdering'] = ObjectSerializer::toQueryValue($pagination_parameters_get_ordering);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsWasteManagementHandedOver
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_waste_management_handed_over_id kezs_waste_management_handed_over_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto
     */
    public function getKezsWasteManagementHandedOver($kezs_waste_management_handed_over_id = null)
    {
        list($response) = $this->getKezsWasteManagementHandedOverWithHttpInfo($kezs_waste_management_handed_over_id);
        return $response;
    }

    /**
     * Operation getKezsWasteManagementHandedOverWithHttpInfo
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_waste_management_handed_over_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsWasteManagementHandedOverWithHttpInfo($kezs_waste_management_handed_over_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto';
        $request = $this->getKezsWasteManagementHandedOverRequest($kezs_waste_management_handed_over_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsWasteManagementHandedOverAsync
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_waste_management_handed_over_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementHandedOverAsync($kezs_waste_management_handed_over_id = null)
    {
        return $this->getKezsWasteManagementHandedOverAsyncWithHttpInfo($kezs_waste_management_handed_over_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsWasteManagementHandedOverAsyncWithHttpInfo
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_waste_management_handed_over_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementHandedOverAsyncWithHttpInfo($kezs_waste_management_handed_over_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto';
        $request = $this->getKezsWasteManagementHandedOverRequest($kezs_waste_management_handed_over_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsWasteManagementHandedOver'
     *
     * @param  string $kezs_waste_management_handed_over_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsWasteManagementHandedOverRequest($kezs_waste_management_handed_over_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementHandedOver/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_waste_management_handed_over_id !== null) {
            $queryParams['KezsWasteManagementHandedOverId'] = ObjectSerializer::toQueryValue($kezs_waste_management_handed_over_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsWasteManagementHandedOvers
     *
     * Lista wpisów \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto[]
     */
    public function getKezsWasteManagementHandedOvers($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        list($response) = $this->getKezsWasteManagementHandedOversWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);
        return $response;
    }

    /**
     * Operation getKezsWasteManagementHandedOversWithHttpInfo
     *
     * Lista wpisów \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsWasteManagementHandedOversWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto[]';
        $request = $this->getKezsWasteManagementHandedOversRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsWasteManagementHandedOversAsync
     *
     * Lista wpisów \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementHandedOversAsync($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        return $this->getKezsWasteManagementHandedOversAsyncWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsWasteManagementHandedOversAsyncWithHttpInfo
     *
     * Lista wpisów \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementHandedOversAsyncWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementHandedOverDto[]';
        $request = $this->getKezsWasteManagementHandedOversRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsWasteManagementHandedOvers'
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsWasteManagementHandedOversRequest($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementHandedOver/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_equipment_group_card_id !== null) {
            $queryParams['KezsEquipmentGroupCardId'] = ObjectSerializer::toQueryValue($kezs_equipment_group_card_id);
        }
        // query params
        if ($pagination_parameters_order_is_ascending !== null) {
            $queryParams['PaginationParameters.Order.IsAscending'] = ObjectSerializer::toQueryValue($pagination_parameters_order_is_ascending);
        }
        // query params
        if ($pagination_parameters_order_order_column !== null) {
            $queryParams['PaginationParameters.Order.OrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_order_order_column);
        }
        // query params
        if ($pagination_parameters_page_index !== null) {
            $queryParams['PaginationParameters.Page.Index'] = ObjectSerializer::toQueryValue($pagination_parameters_page_index);
        }
        // query params
        if ($pagination_parameters_page_size !== null) {
            $queryParams['PaginationParameters.Page.Size'] = ObjectSerializer::toQueryValue($pagination_parameters_page_size);
        }
        // query params
        if ($pagination_parameters_get_order_column !== null) {
            $queryParams['PaginationParameters.GetOrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_column);
        }
        // query params
        if ($pagination_parameters_get_order_direction !== null) {
            $queryParams['PaginationParameters.GetOrderDirection'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_direction);
        }
        // query params
        if ($pagination_parameters_get_ordering !== null) {
            $queryParams['PaginationParameters.GetOrdering'] = ObjectSerializer::toQueryValue($pagination_parameters_get_ordering);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwn
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_waste_management_on_ones_own_id kezs_waste_management_on_ones_own_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto
     */
    public function getKezsWasteManagementOnOnesOwn($kezs_waste_management_on_ones_own_id = null)
    {
        list($response) = $this->getKezsWasteManagementOnOnesOwnWithHttpInfo($kezs_waste_management_on_ones_own_id);
        return $response;
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwnWithHttpInfo
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_waste_management_on_ones_own_id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsWasteManagementOnOnesOwnWithHttpInfo($kezs_waste_management_on_ones_own_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto';
        $request = $this->getKezsWasteManagementOnOnesOwnRequest($kezs_waste_management_on_ones_own_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwnAsync
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_waste_management_on_ones_own_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementOnOnesOwnAsync($kezs_waste_management_on_ones_own_id = null)
    {
        return $this->getKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($kezs_waste_management_on_ones_own_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwnAsyncWithHttpInfo
     *
     * Informacje o wpisie \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_waste_management_on_ones_own_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($kezs_waste_management_on_ones_own_id = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto';
        $request = $this->getKezsWasteManagementOnOnesOwnRequest($kezs_waste_management_on_ones_own_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsWasteManagementOnOnesOwn'
     *
     * @param  string $kezs_waste_management_on_ones_own_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsWasteManagementOnOnesOwnRequest($kezs_waste_management_on_ones_own_id = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementOnOnesOwn/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_waste_management_on_ones_own_id !== null) {
            $queryParams['KezsWasteManagementOnOnesOwnId'] = ObjectSerializer::toQueryValue($kezs_waste_management_on_ones_own_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwns
     *
     * Lista wpisów \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto[]
     */
    public function getKezsWasteManagementOnOnesOwns($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        list($response) = $this->getKezsWasteManagementOnOnesOwnsWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);
        return $response;
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwnsWithHttpInfo
     *
     * Lista wpisów \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getKezsWasteManagementOnOnesOwnsWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto[]';
        $request = $this->getKezsWasteManagementOnOnesOwnsRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwnsAsync
     *
     * Lista wpisów \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementOnOnesOwnsAsync($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        return $this->getKezsWasteManagementOnOnesOwnsAsyncWithHttpInfo($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKezsWasteManagementOnOnesOwnsAsyncWithHttpInfo
     *
     * Lista wpisów \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKezsWasteManagementOnOnesOwnsAsyncWithHttpInfo($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1KezsWasteManagementOnOnesOwnDto[]';
        $request = $this->getKezsWasteManagementOnOnesOwnsRequest($kezs_equipment_group_card_id, $pagination_parameters_order_is_ascending, $pagination_parameters_order_order_column, $pagination_parameters_page_index, $pagination_parameters_page_size, $pagination_parameters_get_order_column, $pagination_parameters_get_order_direction, $pagination_parameters_get_ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKezsWasteManagementOnOnesOwns'
     *
     * @param  string $kezs_equipment_group_card_id  (optional)
     * @param  bool $pagination_parameters_order_is_ascending Flaga ustawiana na true, jeśli zbiór ma być posortowany rosnąco, false w przeciwnym razie (optional)
     * @param  string $pagination_parameters_order_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  int $pagination_parameters_page_index Indeks strony (optional)
     * @param  int $pagination_parameters_page_size Ilość wyników na stronie (min 1, max 50) (optional)
     * @param  string $pagination_parameters_get_order_column Identyfikator kolumny, według której ma być zrelizowane sortowanie (optional)
     * @param  string $pagination_parameters_get_order_direction Kierunek sortowania (optional)
     * @param  string $pagination_parameters_get_ordering Sortowanie (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKezsWasteManagementOnOnesOwnsRequest($kezs_equipment_group_card_id = null, $pagination_parameters_order_is_ascending = null, $pagination_parameters_order_order_column = null, $pagination_parameters_page_index = null, $pagination_parameters_page_size = null, $pagination_parameters_get_order_column = null, $pagination_parameters_get_order_direction = null, $pagination_parameters_get_ordering = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsWasteManagementOnOnesOwn/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kezs_equipment_group_card_id !== null) {
            $queryParams['KezsEquipmentGroupCardId'] = ObjectSerializer::toQueryValue($kezs_equipment_group_card_id);
        }
        // query params
        if ($pagination_parameters_order_is_ascending !== null) {
            $queryParams['PaginationParameters.Order.IsAscending'] = ObjectSerializer::toQueryValue($pagination_parameters_order_is_ascending);
        }
        // query params
        if ($pagination_parameters_order_order_column !== null) {
            $queryParams['PaginationParameters.Order.OrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_order_order_column);
        }
        // query params
        if ($pagination_parameters_page_index !== null) {
            $queryParams['PaginationParameters.Page.Index'] = ObjectSerializer::toQueryValue($pagination_parameters_page_index);
        }
        // query params
        if ($pagination_parameters_page_size !== null) {
            $queryParams['PaginationParameters.Page.Size'] = ObjectSerializer::toQueryValue($pagination_parameters_page_size);
        }
        // query params
        if ($pagination_parameters_get_order_column !== null) {
            $queryParams['PaginationParameters.GetOrderColumn'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_column);
        }
        // query params
        if ($pagination_parameters_get_order_direction !== null) {
            $queryParams['PaginationParameters.GetOrderDirection'] = ObjectSerializer::toQueryValue($pagination_parameters_get_order_direction);
        }
        // query params
        if ($pagination_parameters_get_ordering !== null) {
            $queryParams['PaginationParameters.GetOrdering'] = ObjectSerializer::toQueryValue($pagination_parameters_get_ordering);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchKezs
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1SearchKezsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1SearchKezsResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull
     */
    public function searchKezs($request = null)
    {
        list($response) = $this->searchKezsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation searchKezsWithHttpInfo
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1SearchKezsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1SearchKezsResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchKezsWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1SearchKezsResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKezsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1SearchKezsResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchKezsAsync
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1SearchKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKezsAsync($request = null)
    {
        return $this->searchKezsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchKezsAsyncWithHttpInfo
     *
     * Wyszukiwarka kart
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1SearchKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchKezsAsyncWithHttpInfo($request = null)
    {
        $returnType = '\Swagger\Client\Model\WasteRegisterPublicApiApiModelsCollectionsPaginatedPage1WasteRegisterPublicApiApiModelsResponsesWasteRegisterElectronicWasteRecordCardV1SearchKezsResultDtoWasteRegisterPublicApiVersion1000CultureNeutralPublicKeyTokenNull';
        $request = $this->searchKezsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchKezs'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1SearchKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchKezsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezs
     *
     * Edycja karty i stanów magazynowych zebranego sprzetu
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezs($request = null)
    {
        list($response) = $this->updateKezsWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsWithHttpInfo
     *
     * Edycja karty i stanów magazynowych zebranego sprzetu
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsAsync
     *
     * Edycja karty i stanów magazynowych zebranego sprzetu
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsAsync($request = null)
    {
        return $this->updateKezsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsAsyncWithHttpInfo
     *
     * Edycja karty i stanów magazynowych zebranego sprzetu
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezs'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezsEquipmentCollectingEntry
     *
     * Edycja wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentCollectingEntryRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezsEquipmentCollectingEntry($request = null)
    {
        list($response) = $this->updateKezsEquipmentCollectingEntryWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsEquipmentCollectingEntryWithHttpInfo
     *
     * Edycja wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsEquipmentCollectingEntryWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsEquipmentCollectingEntryRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsEquipmentCollectingEntryAsync
     *
     * Edycja wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsEquipmentCollectingEntryAsync($request = null)
    {
        return $this->updateKezsEquipmentCollectingEntryAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsEquipmentCollectingEntryAsyncWithHttpInfo
     *
     * Edycja wpisu \"Zbieranie sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsEquipmentCollectingEntryAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsEquipmentCollectingEntryRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezsEquipmentCollectingEntry'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentCollectingEntryRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsEquipmentCollectingEntryRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/UpdateKezsEquipmentCollectingEntry/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezsEquipmentManagement
     *
     * Edycja wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentManagementRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezsEquipmentManagement($request = null)
    {
        list($response) = $this->updateKezsEquipmentManagementWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsEquipmentManagementWithHttpInfo
     *
     * Edycja wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsEquipmentManagementWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsEquipmentManagementRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsEquipmentManagementAsync
     *
     * Edycja wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsEquipmentManagementAsync($request = null)
    {
        return $this->updateKezsEquipmentManagementAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsEquipmentManagementAsyncWithHttpInfo
     *
     * Edycja wpisu \"Gospodarowanie sprzętem\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsEquipmentManagementAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsEquipmentManagementRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezsEquipmentManagement'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsEquipmentManagementRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsEquipmentManagementRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/UpdateKezsEquipmentManagement/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezsStockWasteMassGroup
     *
     * Edycja wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsStockWasteMassGroupRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezsStockWasteMassGroup($request = null)
    {
        list($response) = $this->updateKezsStockWasteMassGroupWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsStockWasteMassGroupWithHttpInfo
     *
     * Edycja wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsStockWasteMassGroupWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsStockWasteMassGroupRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsStockWasteMassGroupAsync
     *
     * Edycja wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsStockWasteMassGroupAsync($request = null)
    {
        return $this->updateKezsStockWasteMassGroupAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsStockWasteMassGroupAsyncWithHttpInfo
     *
     * Edycja wpisu Stany magazynowe - \"Wytworzone odpady\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsStockWasteMassGroupAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsStockWasteMassGroupRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezsStockWasteMassGroup'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsStockWasteMassGroupRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsStockWasteMassGroupRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/KezsStockWasteMassGroup/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezsUsedEquipmentWasteGeneration
     *
     * Edycja wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsUsedEquipmentWasteGenerationRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezsUsedEquipmentWasteGeneration($request = null)
    {
        list($response) = $this->updateKezsUsedEquipmentWasteGenerationWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsUsedEquipmentWasteGenerationWithHttpInfo
     *
     * Edycja wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsUsedEquipmentWasteGenerationWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsUsedEquipmentWasteGenerationRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsUsedEquipmentWasteGenerationAsync
     *
     * Edycja wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsUsedEquipmentWasteGenerationAsync($request = null)
    {
        return $this->updateKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo
     *
     * Edycja wpisu \"Wytwarzanie odpadów w wyniku przetworzenia zużytego sprzętu\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsUsedEquipmentWasteGenerationAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsUsedEquipmentWasteGenerationRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezsUsedEquipmentWasteGeneration'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsUsedEquipmentWasteGenerationRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsUsedEquipmentWasteGenerationRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/UpdateKezsUsedEquipmentWasteGeneration/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezsWasteManagementHandedOver
     *
     * Edycja wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementHandedOverRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezsWasteManagementHandedOver($request = null)
    {
        list($response) = $this->updateKezsWasteManagementHandedOverWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsWasteManagementHandedOverWithHttpInfo
     *
     * Edycja wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsWasteManagementHandedOverWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsWasteManagementHandedOverRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsWasteManagementHandedOverAsync
     *
     * Edycja wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsWasteManagementHandedOverAsync($request = null)
    {
        return $this->updateKezsWasteManagementHandedOverAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsWasteManagementHandedOverAsyncWithHttpInfo
     *
     * Edycja wpisu \"Gospodarowanie odpadami - przekazanie innemu posiadaczowi\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsWasteManagementHandedOverAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsWasteManagementHandedOverRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezsWasteManagementHandedOver'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementHandedOverRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsWasteManagementHandedOverRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/UpdateKezsWasteManagementHandedOver/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKezsWasteManagementOnOnesOwn
     *
     * Edycja wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementOnOnesOwnRequest $request request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateKezsWasteManagementOnOnesOwn($request = null)
    {
        list($response) = $this->updateKezsWasteManagementOnOnesOwnWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation updateKezsWasteManagementOnOnesOwnWithHttpInfo
     *
     * Edycja wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKezsWasteManagementOnOnesOwnWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsWasteManagementOnOnesOwnRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateKezsWasteManagementOnOnesOwnAsync
     *
     * Edycja wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsWasteManagementOnOnesOwnAsync($request = null)
    {
        return $this->updateKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKezsWasteManagementOnOnesOwnAsyncWithHttpInfo
     *
     * Edycja wpisu \"Gospodarowanie odpadami - we własnym zakresie\"
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKezsWasteManagementOnOnesOwnAsyncWithHttpInfo($request = null)
    {
        $returnType = 'object';
        $request = $this->updateKezsWasteManagementOnOnesOwnRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKezsWasteManagementOnOnesOwn'
     *
     * @param  \Swagger\Client\Model\WasteRegisterPublicApiApiModelsRequestsWasteRegisterElectronicWasteRecordCardV1UpdateKezsWasteManagementOnOnesOwnRequest $request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateKezsWasteManagementOnOnesOwnRequest($request = null)
    {

        $resourcePath = '/WasteRegister/ElectronicWasteRecordCard/v1/Kezs/KezsEquipmentGroupCard/UpdateKezsWasteManagementOnOnesOwn/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
